* Trema 入門
** OpenFlow プログラミングフレームワーク Trema
*** Trema のセットアップ
Trema は Linux 上で動作します。次のディストリビューションとバージョンで
の動作を保証しています。

 * Ubuntu 10.04 以降 (i386/amd64, デスクトップ版)
 * Debian GNU/Linux 6.0 (i386/amd64)

なお公式にサポートはしていませんが、RedHat などその他の代表的な Linux
ディストリビューションでも動作するはずです。本連載では、Ubuntu の最新バー
ジョンである 11.04 (デスクトップエディション 32 ビット版) を使います。

Trema の提供する trema コマンドの実行には root 権限が必要です。Trema は
内部的に、sudo コマンドを使って root 権限でいくつかのコマンドを実行しま
す。まずは、sudo コマンドを使って root 権限でコマンドを実行できるかどう
か、sudo の設定ファイルを確認してください。

sudo が正しく設定できていることを確認したら、Trema のインストールや実行
に必要ないくつかのソフトウェアをインストールしましょう。

 * Ruby インタプリタ。Trema は Ruby と C で作成されていて、アプリケーショ
   ンの記述にも Ruby を使います。Trema では Ruby のバージョン 1.8.7 が
   必要です。1.8.6 以前のバージョンやバージョン 1.9 以降では今のところ
   動作しません。
 * Ruby のパッケージ管理システム RubyGems (https://rubygems.org/)
 * Trema 本体。本書は、Trema バージョン 0.3.0 を使用して執筆しています。
 * Trema のコンパイルに必要な gcc や make、およびいくつかのライブラリ。

Trema の実行に必要なのはこれだけです。それでは、Ubuntu のパッケージ管理
システム apt-get を使って必要なパッケージを次のようにインストールしてく
ださい。もし他のディストリビューションを使いたい場合は、コマンド名とパッ
ケージ名を適宜読み替えください。

#+BEGIN_SRC
prompt> sudo apt-get install git gcc make ruby ruby-dev libpcap-dev libsqlite3-dev
#+END_SRC

以上で Trema をインストールするための準備が整いました。続いて Trema を
インストールするには、RubyGems のパッケージで手軽にインストールする方法
と、最新のソースコードを取得して自分でビルドする方法があります。それぞ
れ説明していきましょう。

**** パッケージで手軽にインストールする場合

Trema は RubyGems を使って次のようにコマンド一発で簡単にインストールできます。

#+BEGIN_SRC
prompt> gem install trema
#+END_SRC

RubyGems でインストールした場合、自動的に Trema のコマンド trema にパス
が通っているはずです。次のコマンドでバージョンが表示されればインストー
ルは成功です。

#+BEGIN_SRC
prompt> trema --version
trema version 0.3.0
#+END_SRC

**** ソースコードから最新版をインストールする場合

最新版をインストールしたい人は、GitHub から自分でソースコードをダウンロー
ドしてビルドすることもできます。まず、次のように git を使って最新のソー
スコードを取得してください。

#+BEGIN_SRC
prompt> git clone git://github.com/trema/trema.git
#+END_SRC

次のコマンドを実行すると、Trema が依存する RubyGems のパッケージが自動
的にインストールされます。

#+BEGIN_SRC
prompt> cd trema
prompt> gem install bundler
prompt> bundle install
#+END_SRC

次のコマンドで Trema をダウンロードしたディレクトリ以下に Trema がイン
ストールされます。make install のようなシステム全体へのインストール手順
は不要です。

#+BEGIN_SRC
prompt> ./build.rb
#+END_SRC

次のコマンドで trema コマンドが正しくインストールされたか確認してくださ
い。

#+BEGIN_SRC
prompt> ./trema --version
trema version 0.3.0
#+END_SRC

もし必要あればこのディレクトリにパスを通し、trema コマンドが簡単に起動
できるようにしておいてください。

さあ、これで Trema による OpenFlow 開発環境が整いました。それでは早速、
入門の定番 Hello, World を Trema で書いてみましょう。

*** Hello, Trema!
今から書くアプリケーションは最も簡単な OpenFlow コントローラの一種で、
画面に「 =Hello, Trema!= 」と表示するだけのものです。スイッチとはまった
くやりとりしないスタンドアロンのアプリケーションですが、Trema で作れる
コントローラの基本がすべて入っています。

では、適当なディレクトリにエディタで =hello-trema.rb= というファイルを
開き、次のコードを入力してください。"=.rb=" は Ruby プログラムの標準的
な拡張子です。なお Ruby の文法は必要に応じておいおい説明しますので、も
し分からなくても今のところは気にせずそのまま入力してください。

#+CAPTION: Hello Trema! コントローラ
#+name: src:hello
#+BEGIN_SRC ruby
  class HelloController < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

意味はまだわからないかもしれませんが、とてもシンプルに見えますね。それ
では細かい文法は後で見るとして「習うより慣れろ」でさっそく実行してみま
しょう。

**** 実行してみよう (trema run)

作成したコントローラは =trema run= コマンドですぐに実行できます。Rubyは
インタプリタ言語なので、コンパイルの必要はありません。ターミナルで次の
ように入力すると、この世界一短い OpenFlow コントローラはフォアグラウン
ドプロセスとして起動し、画面に =Hello, Trema!= と出力します。起動したコ
ントローラは =Ctrl + c= で停止できます。

#+BEGIN_SRC
prompt> cd trema
prompt> ./trema run ./hello-trema.rb
Hello, Trema!  # Ctrl-c で終了
prompt>
#+END_SRC

いかがでしょうか？ trema コマンドを使うと、とても簡単にコントローラを実
行できます。=trema= コマンドは Trema のコマンドラインツールであり、コン
トローラの起動やテストなど様々な用途に使います。たとえば先ほどの
「Hello Trema!」で見たように、 =trema run= はコントローラを起動するため
のコマンドです。起動したコントローラは OpenFlow スイッチと接続しメッセー
ジをやりとりします。

このコントローラは何もしてくれませんが、Trema でコントローラを書くのに
必要な知識がひととおり含まれています。スイッチをつなげるのはちょっと辛
抱して、まずはソースコードを見ていきましょう。

**** コントローラクラスを定義する
Ruby で書く場合、すべてのコントローラは Controller クラスを継承して定義
します ([[src:hello][リスト 1 (1)]])。

Controller クラスを継承することで、コントローラに必要な基本機能が
HelloController クラスにこっそりと追加されます。

**** ハンドラを定義する
Trema はイベントドリブンなプログラミングモデルを採用しています。つまり、
OpenFlow メッセージの到着など各種イベントに対応するハンドラを定義してお
くと、イベントの発生時に対応するハンドラが呼び出されます。たとえば
start メソッドを定義しておくと、コントローラの起動時にこれが自動的に呼
ばれます ([[src:hello][リスト 1 (2)]])。

さて、これで Trema の基本はおしまいです。次は、いよいよ実用的な
OpenFlow コントローラを書いて実際にスイッチをつないでみます。

*** スイッチモニタリングツール
次のお題はスイッチのモニタリングツールです。「今、ネットワーク中にどの
スイッチが動いているか」をリアルタイムに表示しますので、何らかの障害で
落ちてしまったスイッチを発見するのに便利です。

スイッチモニタリングツールは図 2 のように動作します。

OpenFlow スイッチは，起動すると OpenFlow コントローラへ接続しに行きます。
Trema では，スイッチとの接続が確立すると，コントローラの switch_ready
ハンドラが呼ばれます。コントローラはスイッチ一覧リストを更新し，新しく
起動したスイッチをリストに追加します。逆にスイッチが何らかの原因で接続
を切った場合，コントローラの `switch_disconnected` ハンドラが呼ばれます。
コントローラはリストを更新し，いなくなったスイッチをリストから削除しま
す。

**** 仮想ネットワーク

それでは早速，スイッチの起動を検知するコードを書いてみましょう。なんと，
Trema を使えば OpenFlow スイッチを持っていなくてもこうしたコードを実行
してテストできます。いったいどういうことでしょうか?

その答えは，Trema の強力な機能の 1 つ，仮想ネットワーク構築機能にありま
す。これは仮想 OpenFlow スイッチや仮想ホストを接続した仮想ネットワーク
を作る機能です。この仮想ネットワークとコントローラを接続することによっ
て，物理的な OpenFlow スイッチやホストを準備しなくとも，開発マシン 1 台
で OpenFlow コントローラと動作環境を一度に用意して開発できます。もちろ
ん，開発したコントローラは実際の物理的な OpenFlow スイッチやホストで構
成されたネットワークでもそのまま動作します!

それでは仮想スイッチを起動してみましょう。

**** 仮想 OpenFlow スイッチを起動する

仮想スイッチを起動するには，仮想ネットワークの構成を記述した設定ファイ
ルを `trema run` に渡します。たとえば，リスト 2 の設定ファイルでは仮想
スイッチ (`vswitch`) を 2 台定義しています。

#+BEGIN_SRC ruby
vswitch { datapath_id 0xabc }
vswitch { datapath_id 0xdef }
#+END_SRC

リスト2　仮想ネットワークに仮想スイッチを2台追加

それぞれに指定されている `datapath_id` (`0xabc`， `0xdef`) はネットワー
クカードにおける MAC アドレスのような存在で，スイッチを一意に特定する
ID として使われます。OpenFlow の規格によると，64 ビットの一意な整数値を
OpenFlow スイッチ 1 台ごとに割り振ることになっています。仮想スイッチで
は好きな値を設定できるので，かぶらないように適当な値をセットしてくださ
い。

#+BEGIN_SRC ruby
class SwitchMonitor < Controller
  periodic_timer_event :show_switches, 10 # (3)

  def start
    @switches = []
  end

  def switch_ready datapath_id # (1)
    @switches << datapath_id.to_hex
    info "Switch #{ datapath_id.to_hex } is UP"
  end

  def switch_disconnected datapath_id # (2)
    @switches -= [datapath_id.to_hex ]
    info "Switch #{ datapath_id.to_hex } is DOWN"
  end

  private # (3)
  def show_switches
    info "All switches = " + @switches.sort.join( ", " )
  end
end
#+END_SRC

リスト3　SwitchMonitor コントローラ

それでは，さきほど定義したスイッチを起動してコントローラから捕捉してみ
ましょう。スイッチの起動イベントを捕捉するには `switch_ready` ハンドラ
を書きます (リスト 3-1)。

`@switches` は現在起動しているスイッチのリストを管理するインスタンス変
数で，新しくスイッチが起動するとスイッチの `datapath_id` が追加されます。
また，`puts` メソッドで `datapath_id` を表示します。

**** スイッチの切断を捕捉する

同様に，スイッチが落ちて接続が切れたイベントを捕捉してみましょう。この
ためのハンドラは `switch_disconnected` です (リスト 3-2)。

スイッチの切断を捕捉すると，切断したスイッチの `datapath_id` をスイッチ
一覧 `@switches` から除きます。また，`datapath_id` を `puts` メソッドで
表示します。

**** スイッチの一覧を表示する

最後に，スイッチの一覧を定期的に表示する部分を作ります。一定時間ごとに
何らかの処理を行いたい場合には，タイマー機能を使います。リスト 3-3 のよ
うに，一定の間隔で呼びたいメソッドと間隔 (秒数) を
`periodic_timer_event` で指定すると，指定されたメソッドが呼ばれます。こ
こでは，スイッチの一覧を表示するメソッド `show_switches` を 10 秒ごとに
呼び出します。

**** 実行

それでは早速実行してみましょう。仮想スイッチを 3 台起動する場合，リスト
4 の内容のファイルを `switch-monitor.conf` として保存し，設定ファイルを
`trema run` の `-c` オプションに渡してください。

#+BEGIN_SRC ruby
vswitch { datapath_id 0x1 }
vswitch { datapath_id 0x2 }
vswitch { datapath_id 0x3 }
#+END_SRC

リスト4　仮想スイッチを3台定義

実行結果は次のようになります。

#+BEGIN_SRC
    % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
    Switch 0x3 is UP
    Switch 0x2 is UP
    Switch 0x1 is UP
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    ……
#+END_SRC

`switch-monitor` コントローラが起動すると設定ファイルで定義した仮想スイッ
チ 3 台が起動し，`switch-monitor` コントローラの `switch_ready` ハンド
ラによって捕捉され，このメッセージが出力されました。

それでは，スイッチの切断がうまく検出されるか確かめてみましょう。スイッ
チを停止するコマンドは `trema kill` です。別ターミナルを開き，次のコマ
ンドでスイッチ `0x3` を落としてみてください。

#+BEGIN_SRC
    % ./trema kill 0x3
#+END_SRC

すると，`trema run` を動かしたターミナルに次の出力が表示されているはず
です。

#+BEGIN_SRC
    % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
    Switch 0x3 is UP
    Switch 0x2 is UP
    Switch 0x1 is UP
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    ……
    Switch 0x3 is DOWN
#+END_SRC

うまくいきました! おわかりのとおり，このメッセージは
`switch_disconnected` ハンドラによって表示されたものです。

**** 友太郎の質問 datapath ってなに?

Q. 「こんにちは! 僕は最近 OpenFlow に興味を持ったプログラマ，友太郎です。
   スイッチに付いている ID を datapath ID って呼ぶのはわかったけど，いっ
   たい datapath ってなに? スイッチのこと?」

A. 実用的には 「datapath = OpenFlow スイッチ」 と考えて問題ありません。

「データパス」 でググると，「CPUは演算処理を行うデータパスと，指示を出
すコントローラから構成されます」 というハードウェア教科書の記述がみつか
ります。つまり，ハードウェアの世界では一般に 「筋肉にあたる部分 = デー
タパス」「脳にあたる部分 = コントローラ」 という分類をするようです。

OpenFlow の世界でも同じ用法が踏襲されています。OpenFlow のデータパスは
パケット処理を行うスイッチを示し，その制御を行うソフトウェア部分をコン
トローラと呼びます。

** まとめ

すべてのコントローラのテンプレートとなる Hello, Trema! コントローラを書
きました。また，これを改造してスイッチの動作状況を監視するスイッチモニ
タを作りました。学んだことは次の3つです。

- OpenFlow ネットワークはパケットを処理するスイッチ (datapath) と，スイッ
  チを制御するソフトウェア (コントローラ) から構成される。Trema は，こ
  のコントローラを書くためのプログラミングフレームワークである
- Trema は仮想ネットワーク構築機能を持っており，OpenFlow スイッチを持っ
  ていなくてもコントローラの開発やテストが可能。たとえば，仮想ネットワー
  クに仮想スイッチを追加し，任意の datapath ID を設定できる
- コントローラは Ruby の Controller クラスを継承し，OpenFlow の各種イベ
  ントに対応するハンドラを定義することでスイッチをコントロールできる。
  たとえば，`switch_ready` と `switch_disconnected` ハンドラでスイッチ
  の起動と切断イベントに対応するアクションを書ける

次回はいよいよ本格的なコントローラとして，トラフィック集計機能のあるレ
イヤ 2 スイッチを作ります。初歩的なレイヤ 2 スイッチング機能と，誰がど
のくらいネットワークトラフィックを発生させているかを集計する機能を
OpenFlow で実現します。

**** 友太郎の質問: `switch_ready` ってなに ?

Q. 「OpenFlow の仕様を読んでみたけど，どこにも `switch_ready` って出て
   こなかったよ? OpenFlow にそんなイベントが定義されてるの?」

A. `switch_ready` は Trema 独自のイベントで，スイッチが Trema に接続し
   指示が出せるようになった段階でコントローラに送られます。実は，
   `switch_ready` の裏では図 A の一連の処理が行われており，Trema が
   OpenFlow プロトコルの詳細をうまくカーペットの裏に隠してくれているの
   です。

図A　switch_ready イベントが起こるまで

最初に，スイッチとコントローラがしゃべる OpenFlow プロトコルが合ってい
るか確認します。OpenFlow の `HELLO` メッセージを使ってお互いのプロトコ
ルバージョンを確認し，うまく会話できそうか確認します。

次は，スイッチを識別するための datapath ID の取得です。datapath ID のよ
うなスイッチ固有の情報は，スイッチに対して OpenFlow の Features
Request メッセージを送ることで取得できます。成功した場合，datapath ID
やポート数などの情報が Features Reply メッセージに乗ってやってきます。

最後にスイッチを初期化します。スイッチに以前の状態が残っていると，コン
トローラが管理する情報と競合が起こるため，初期化することでこれを避けま
す。これら一連の処理が終わると，ようやく `switch_ready` がコントローラ
に通知されます。

* OpenFlow 入門
今回は盛りだくさんです！ まずは身近な例を使って，OpenFlow の動作モデル
を説明します。これが理解できれば，OpenFlow の基本概念はバッチリです。次
に，「トラフィック集計付きスイッチ」 を実現するコントローラを実際に作り
ます。これは OpenFlow の重要な処理をすべて含んでいるので，応用するだけ
でさまざまなタイプのコントローラが作れるようになります。最後に，作成し
たコントローラを Trema の仮想ネットワーク上で実行します。すばらしいこと
に，Trema を使えば開発から動作テストまでを開発マシン 1 台だけで完結でき
ます！

では前置きはこのぐらいにして，まずは OpenFlow でスイッチを制御するしく
みを理解しましょう。

** OpenFlow の動作モデル

OpenFlow の動作を現実世界にたとえると，製品の電話サポートサービスに似て
います。


*** 電話サポートの業務手順

友太郎 (ゆうたろう) 君は，エアコンが故障したので修理に出そうと考えまし
た （図1）。電話サポートに問い合わせると，サポート係の葵 （あおい） さ
んはエアコンの症状を聞き，手元のマニュアルに対処方法が載っている場合に
はこれをすぐに教えてくれます。問題は，マニュアルに対処法が載っていない
場合です。このようなときは少し時間がかかりますが，上司の宮坂主任にどう
したらよいか聞きます。そして，宮坂主任からの回答が得られたら，葵さんは
友太郎君に折り返し電話をします。また，次からの同じ問い合わせにはすばや
く答えられるようにするため，葵さんは教わった対処法を手元のマニュアルに
追加しておきます。

簡単ですね？ 信じられないかもしれませんが，あなたはすでに OpenFlow の
95% を理解したも同然なのです。

![電話サポートの業務手順](https://github.com/trema/Programming-Trema/raw/master/images/2_001.png)

図1　電話サポートの業務手順

*** OpenFlowに置き換えると……

OpenFlow では，お客さんがパケットを発生させるホスト，電話サポート係がス
イッチ，上司がコントローラ，マニュアルがスイッチのフローテーブル (後述)
に対応します （図2）。

![OpenFlowの動作モデル](https://github.com/trema/Programming-Trema/raw/master/images/2_002.png)

図2　OpenFlowの動作モデル

スイッチはホストからのパケットを受信すると，最初はその処理方法がわかり
ません。そこで，上司にあたるコントローラに問い合わせます。この問い合わ
せを `packet_in` メッセージと呼びます。コントローラはこれを受け取ると，
同様のパケットが届いた場合にスイッチでどう処理すべきか (パケットを転送
する，書き換えるなど) を決めます。これをアクションと呼びます。そして
「スイッチで処理すべきパケットの特徴」＋「アクション」 の組 （フローと
呼びます） をスイッチのマニュアルに追加します。この命令を `flow_mod` メッ
セージと呼び，スイッチのマニュアルをフローテーブルと呼びます。処理すべ
きパケットの特徴とアクションをフローテーブルに書いておくことで，以後，
これに当てはまるパケットはスイッチ側だけですばやく処理できます。忘れて
はならないのが，`packet_in` メッセージで上がってきた最初のパケットです。
これはコントローラに上がってきて処理待ちの状態になっているので，
`packet_out` メッセージで適切な宛先に転送してあげます。

電話サポートとの大きな違いは，フローテーブルに書かれたフローには期限が
あり，これを過ぎると消えてしまうということです。これは，「マニュアルに
書かれた内容は徐々に古くなるので，古くなった項目は消す必要がある」 と考
えるとわかりやすいかもしれません。フローが消えるタイミングでコントロー
ラには `flow_removed` メッセージが送信されます。これには，あるフローに
従ってパケットがどれだけ転送されたか -- 電話サポートの例で言うと，マニュ
アルのある項目が何回参照されたか -- つまり，トラフィックの集計情報が記
録されています。

それではしくみの話はこのぐらいにして，早速実践に移りましょう。もし途中
でわからなくなったら，この節の頭から読み直してください。


** 「トラフィック集計スイッチ」 コントローラの概要

トラフィック集計スイッチは，パっと見は普通の L2 スイッチとして動作しま
す。しかし，裏では各ホストが送信したトラフィックをカウントしており，定
期的に集計情報を表示してくれます。これを使えば，ネットワークを無駄に使
いすぎているホストを簡単に特定できます。

*** 設計と実装

「L2 スイッチ機能」と「トラフィックの集計機能」のためにはどんな部品が必
要でしょうか？ まずは，スイッチに指示を出す上司にあたるコントローラクラ
スが必要です。これを `TrafficMonitor` クラスと名付けましょう。また，パ
ケットを宛先のスイッチポートへ届けるための `FDB` クラス (注1)，あとはト
ラフィックを集計するための `Counter` クラスの 3 つが最低限必要です。

注1) FDB とは Forwarding DataBase の略で，スイッチの一般的な機能です。詳しくは続く実装で説明します。

*** FDBクラス

`FDB` クラス (リスト1) は，ホストの MAC アドレスとホストが接続している
スイッチポートの対応を学習するデータベースです。このデータベースを参照
することで，`packet_in` メッセージで入ってきたパケットの宛先 MAC アドレ
スからパケット送信先のスイッチポートを決定できます。

#+BEGIN_SRC ruby
class FDB
  def initialize
    @db = {} # <- 連想配列(MACアドレス→スイッチポート番号)
  end

  def lookup mac # <- MACアドレスからスイッチポート番号を引く
    @db[ mac ]
  end

  def learn mac, port_number # <- MACアドレス＋スイッチポートを学習
    @db[ mac ] = port_number
  end
end
#+END_SRC

リスト1　MACアドレス→スイッチポートのデータベースFDBクラス(fdb.rb)

*** Counter クラス

`Counter` クラス (リスト2) は，ホスト （MAC アドレスで区別します） ごと
の送信パケット数およびバイト数をカウントします。また，カウントした集計
情報を表示するためのヘルパメソッドを提供します。

#+BEGIN_SRC ruby
class Counter
  def initialize
    @db = {} # <- ホストごとの集計情報を記録する連想配列
  end

  def add mac, packet_count, byte_count # <- ホスト (MAC アドレス = mac) の送信パケット数、バイト数を追加
    @db[ mac ] ||= { :packet_count => 0, :byte_count => 0 }
    @db[ mac ][ :packet_count ] += packet_count
    @db[ mac ][ :byte_count ] += byte_count
  end

  def each_pair &block # <- 集計情報の表示用
    @db.each_pair &block
  end
end
#+END_SRC

リスト2　トラフィックを記録し集計する `Counter` クラス (`counter.rb`)

*** TrafficMonitor クラス

`TrafficMonitor` クラスはコントローラの本体です (リスト3)。メインの処理
はリスト 3 1-3 の 3 つになります。

1. `packet_in` メッセージが到着したとき，パケットを宛先のスイッチポートに転送し，フローテーブルを更新する部分
2. `flow_removed` メッセージが到着したとき，トラフィック集計情報を更新する部分
3. タイマーで 10 秒ごとにトラフィックの集計情報を表示する部分

#+BEGIN_SRC ruby
require "counter"
require "fdb"

class TrafficMonitor < Controller
  periodic_timer_event :show_counter, 10 # (3)

  def start
    @counter = Counter.new # <- Counter オブジェクト
    @fdb = FDB.new # <- FDB オブジェクト
  end

  def packet_in datapath_id, message # (1)
    macsa = message.macsa # <- パケットを送信したホストの MAC アドレス
    macda = message.macda # <- パケットの宛先ホストの MAC アドレス

    @fdb.learn macsa, message.in_port
    @counter.add macsa, 1, message.total_len
    out_port = @fdb.lookup( macda )
    if out_port
      packet_out datapath_id, message, out_port
      flow_mod datapath_id, macsa, macda, out_port
    else
      flood datapath_id, message
    end
  end

  def flow_removed datapath_id, message # (2)
    @counter.add message.match.dl_src,message.packet_count, message.byte_count
  end

  private # <- 以下、プライベートメソッド

  def show_counter # <- カウンタを表示
    puts Time.now
    @counter.each_pair do | mac, counter |
      puts "#{ mac } #{ counter[ :packet_count ] } packets (#{ counter[ :byte_count ] } bytes)"
    end
  end

  def flow_mod datapath_id, macsa, macda, out_port # <- macsa から macda へのパケットを out_port へ転送する flow_mod を打つ
    send_flow_mod_add(
      datapath_id,
      :hard_timeout => 10, # <- flow_mod の有効期限は10秒
      :match => Match.new( :dl_src => macsa, :dl_dst => macda ),
      :actions => Trema::ActionOutput.new( out_port )
    )
  end

  def packet_out datapath_id, message, out_port # <- packet_in したメッセージを out_port へ転送
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => Trema::ActionOutput.new( out_port )
    )
  end

  def flood datapath_id, message # <- packet_inしたメッセージをin_port以外の全スイッチポートへ転送
    packet_out datapath_id, message, OFPP_FLOOD
  end
end
#+END_SRC

リスト3　本体 `TrafficMonitor` クラス (`traffic-monitor.rb`)

それでは，とくに重要な (1) の処理を詳しく見ていきましょう。なお，リスト
3 中で使われているメソッドの引数など API の詳細については，「Trema
Ruby API ドキュメント」 を参照してください。

以下の説明では図 3 に示すホスト 2 台 + スイッチ 1 台からなるネットワー
ク構成を使います。host1 から host2 にパケットを送信したときの動作シーケ
ンスは図 4 のようになります。

![TrafficMonitor を動作させるネットワーク構成の例](https://github.com/trema/Programming-Trema/raw/master/images/2_003.png)

図3　`TrafficMonitor` を動作させるネットワーク構成の例

![host1からhost2宛にパケットを送信したときの動作シーケンス](https://github.com/trema/Programming-Trema/raw/master/images/2_004.png)

図4　`host1` から `host2` 宛にパケットを送信したときの動作シーケンス

1. `host1` から `host2` を宛先としてパケットを送信すると，まずはスイッ
   チにパケットが届く
2. スイッチのフローテーブルは最初はまっさらで，どう処理すればよいかわか
   らない状態なので，コントローラである `TrafficMonitor` に
   `packet_in` メッセージを送る
3. `TrafficMonitor` の `packet_in` メッセージハンドラでは，`packet_in`
   メッセージの `in_port` (`host1` のつながるスイッチポート) と
   `host1` の MAC アドレスを FDB に記録する
4. また，`Counter` に記録された `host1` の送信トラフィックを 1 パケット
   分増やす
5. `packet_in` メッセージの宛先 MAC アドレスから転送先のスイッチポート
   番号を FDB に問い合わせる。この時点では `host2` のスイッチポートは学
   習していないので，結果は 「不明」
6. そこで，パケットを `in_port` 以外のすべてのスイッチポートに出力する
   `packet_out` メッセージ (FLOOD と呼ばれる) をスイッチに送り，
   `host2` が受信してくれることを期待する
7. スイッチは，パケットを `in_port` 以外のすべてのポートに出す

これで，最終的に `host2` がパケットを受信できます。逆に，この状態で
`host1` を宛先として `host2` からパケットを送信したときの動作シーケンス
は次のとおりになります (図5)。4 までの動作は図 4 と同じですが，5 からの
動作が次のように異なります。

![host1 から host2 宛にパケットを送信したときの動作シーケンス](https://github.com/trema/Programming-Trema/raw/master/images/2_005.png)

図5　host1 から host2 宛にパケットを送信したときの動作シーケンス

1. `host1` から `host2` を宛先としてパケットを送信すると，まずはスイッ
   チにパケットが届く
2. スイッチのフローテーブルは最初はまっさらで，どう処理すればよいかわか
   らない状態なので，コントローラである `TrafficMonitor` に
   `packet_in` メッセージを送る
3. `TrafficMonitor` の `packet_in` メッセージハンドラでは，`packet_in`
   メッセージの `in_port` (`host1` のつながるスイッチポート) と
   `host1` の MAC アドレスを FDB に記録する
4. また，`Counter` に記録された `host1` の送信トラフィックを 1 パケット
   分増やす
5. `packet_in` メッセージの宛先 MAC アドレスから，転送先のスイッチポー
   ト番号を FDB に問い合わせる。これは，先ほど `host1` から `host2` に
   パケットを送った時点で FDB に学習させているので，送信先はスイッチポー
   ト 1 番ということがわかる
6. そこで，`TrafficMonitor` はパケットをスイッチポート 1 番へ出力する
   `packet_out` メッセージをスイッチに送る。スイッチはこれを受け取ると，
   パケットをスイッチポート 1 番に出し，最終的に `host1` がパケットを受
   信する
7. 「送信元 = 00:00:00:00:00:02，送信先 = 00:00:00:00:00:01 となるパケッ
   トはスイッチポート 1 番に転送せよ」 という `flow_mod` メッセージをス
   イッチに送信する

最後の 7 によって，以降の `host2` から `host1` へのパケットはすべてスイッチ側だけで処理されるようになります。

** 実行してみよう

それでは，早速実行してみましょう (注2)。リスト 4 の内容の仮想ネットワー
ク設定を `traffic-monitor.conf` として保存し，次のように実行してくださ
い。

#+BEGIN_SRC
    % ./trema run ./traffic-monitor.rb -c ./traffic-monitor.conf
#+END_SRC

リスト 4　仮想スイッチ `0xabc` に仮想ホスト `host1`，`host2` を接続する設定

#+BEGIN_SRC ruby
vswitch { # <- 仮想スイッチ 0xabc を定義
  datapath_id 0xabc
}

vhost ("host1") { # <- 仮想ホスト host1 を定義
  ip "192.168.0.1"
  mac "00:00:00:00:00:01"
}

vhost ("host2") { # <- 仮想ホスト host2 を定義
  ip "192.168.0.2"
  mac "00:00:00:00:00:02"
}

link "0xabc", "host1" # <- ホスト host1、host2 をスイッチ 0xabc に接続
link "0xabc", "host2"
#+END_SRC

実行すると，図 3 に示した仮想ネットワークが構成され，`TrafficMonitor`
コントローラが起動します。

それでは，実際にトラフィックを発生させて集計されるか見てみましょう。
Trema の `send_packets` コマンドを使うと，仮想ホスト間で簡単にパケット
を送受信できます。別ターミナルを開き，次のコマンドを入力してください。

#+BEGIN_SRC
    % ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10← host1からhost2宛にパケットを10個送る
    % ./trema send_packets --source host2 --dest host1 --n_pkts 10 --pps 10← host2からhost1宛にパケットを10個送る
#+END_SRC

`trema run` を実行した元のターミナルに次のような出力が出ていれば成功です(注3)。

#+BEGIN_SRC
    ...
    00:00:00:00:00:01 10 packets (640 bytes)
    ↑host1からパケットが10個送信された

    00:00:00:00:00:02 10 packets (640 bytes)
    ↑host2からパケットが10個送信された
    ...
#+END_SRC

注2) Trema のセットアップが済んでいない人は，前回もしくは Trema のドキュメントを参考にセットアップしておいてください。なお，Trema は頻繁に更新されていますので，すでにインストールしている人も最新版にアップデートすることをお勧めします。

注3) その他のトラフィック情報も出るかもしれませんが，これは Linux カーネルが送っている IPv6 のパケットなので，`host1`， `host2` とは関係ありません。


** まとめ

今回は 「トラフィック集計機能付きスイッチ」 を実現するコントローラを書
きました。学んだことは次の2つです。

- 電話サポートの例を使って OpenFlow の動作モデルを学びました。パケット
  の転送はスイッチ上のフローテーブルによって行われ，`flow_mod` メッセー
  ジによって書き換えることができます。また，フローテーブルに登録されて
  いないパケットによって `packet_in` メッセージがコントローラに届きます。
- 仮想ネットワークを使ったコントローラの動作テスト方法を学びました。仮
  想スイッチと仮想ホストを起動してつなぎ，`send_packets` コマンドを使っ
  て仮想ホスト間でパケットを送受信することで，コントローラの簡単な動作
  テストができます。

次回は Trema を使ったテストファースト開発を紹介します。Rails や
Sinatra を使った Web アジャイル開発ではお馴染みのテストファースト開発で
すが，もちろん Trema でもサポートしています。とくに OpenFlow コントロー
ラのように複雑な動作シーケンスを持つソフトウェアの実装には，テストファー
ストによるインクリメンタルな開発が有効です。

* 実践あるのみ! 生活ネットワークを OpenFlow に移行しよう

そろそろ独り立ちするときがやってきました．これまで本連載では，OpenFlow
コントローラの書き方と Trema の仮想ネットワークを使った実行方法を学び
ました．OpenFlow プログラマとしてやっていくための基本的な知識はすべて
身に付きました．次はなにをすればよいでしょうか？あとはやってみるだけで
す．まずは自宅のネットワークを OpenFlow で置き換えましょう．うまくいっ
たら，こんどは職場のネットワークを OpenFlow で置き換えましょう．その環
境で実際に暮らしてみて，初めて見えてくるアイデアや改善案があります．こ
れは，とにかくやってみなければ絶対にわからないことです．

「怒られるかもしれない」．あなたはそう考えます．家のネットワークはとも
かく，職場のネットワークを止めてしまったらどうしよう…．管理者や上司に
注意されたらどうしよう…．大丈夫です．筆者たちも何度も怒られたことがあ
りますが，その経験からうまくやる方法を学びました．

今回は我々の経験を踏まえ，既存のネットワークを穏便に OpenFlow へ移行す
るためのテクニックを教えます．ちょっとした OpenFlow プログラムを書くだ
けで，移行の際に起こりがちなネットワーク障害を簡単に防げます．まずは，
筆者たちの失敗談を振り返らせてください．

** 失敗談
話は 2009 年 7 月までさかのぼります．OpenFlow が登場したばかりの当時，
筆者たちはさっそく OpenFlow コントローラを書いて小さなネットワークを職
場に構築しました．うまく動作して気を良くした我々は，職場のネットワーク
とこの OpenFlow ネットワークをいきなりつないでみました．まあ大丈夫だろ
うと楽観的に考えていたのです．結果的にはすぐにネットワーク障害が起こり，
自体に気付いた管理者からお叱りのメールを受け取ることになりました．

当時の状況を単純化すると図 1 のようになります．職場ネットワーク (レガ
シーネットワークとします) のスイッチにはホストがつながれており，そのう
ちのスイッチポート 3 番を OpenFlow スイッチポートの 1 番と接続しました．
この OpenFlow スイッチは，我々が書いた BuggyController という OpenFlow
コントローラで制御されています．

*** 「警告が出ているんですけど」
具体的な障害の症状はこうでした．レガシーネットワークと OpenFlow ネット
ワークを接続してすぐに，レガシースイッチにつながったホストどうしが通信
できなくなりました．そして，ネットワークを監視する watchdog プログラム
が「Host Flapping が起こっている」という警告を出しました．これは，1 つ
のホストがいくつかのポートの間で高速に移動しているように見えるというも
のです．我々はすぐに OpenFlow ネットワークを切断し，原因の分析にとりか
かりました．

*** 障害の原因
分析の結果，次のようなシナリオで起こっているのではないかという結論に至
りました．

1. host1 が host2 へパケットを送信する
2. BuggyController は OpenFlow スイッチポート 1 番からの packet_in を
   受け取り，OpenFlow スイッチのスイッチポート 1 番に host1 がつながっ
   ていると学習する
3. host2 が host1 へパケットを送信する
4. BuggyController はスイットポート 1 番から「宛先=host1」の packet_in
   を受け取る．ここで，host1 は OpenFlow スイッチのスイッチポート 1 番
   にあると学習しているので，スイッチポート 1 番に packet_out する
5. 結果的に，host1 はポート 2 と 3 の両方から同じパケットを受け取る．
   外から見ると，host2 がスイッチポート 2 番と 3 番を高速に移動してい
   るように見える．

つまり，BuggyController が予期せぬパケットをレガシーネットワークに送っ
たおかげでネットワークが混乱し，通信できない状況が起きたのです．

*** 教訓: これをやってはいけない
振り返ると，失敗した原因は 2 つありました．

1 つは，OpenFlow ネットワークをいきなりレガシーネットワークとつないで
しまったことです．OpenFlow ネットワーク単体では動いていたという言い訳
はありますが，いきなりつないでしまったのは若気の至り & 経験不足でした．

もう 1 つは，BuggyController が packet_in したスイッチポートに
packet_out していたことです．assert を入れるなど防御的プログラミングが
徹底できていれば防げるバグでしたが，残念ながら当時の我々では気づくこと
ができませんでした．レガシーネットワークにつないで初めて顕在化するバグ
と言えます．

** OpenFlow への移行パターン
大失敗をやらかしてしまった筆者たちは，作戦を練りなおさざるを得なくなり
ました。いろいろな方向から考えなおしたところ，OpenFlowへの移行方法には
次の3つのパターンがあることがわかりました。もちろん，それぞれでメリット／
デメリットや危険度が異なります。

*** ①独立ネットワークパターン

最初のパターンは，既存のレガシーネットワークにまったく手を加えずに，独
立した形でOpenFlowネットワークを構築する方法です（図2）。それぞれのネッ
トワーク間でパケットの行き来はなく，お互いに完全に独立しています。

図2　レガシーネットワークとは独立したOpenFlowネットワークを構築し，徐々に拡大する

この状態から，レガシーネットワーク内のサーバや端末を徐々にOpenFlowネッ
トワークに移動することで移行していきます。

それぞれのネットワーク間ではパケットが行き来できないので，OpenFlowネッ
トワークがレガシーネットワークに悪影響を及ぼす可能性はほとんどありませ
ん。ただし，OpenFlowネットワークに移行する際には関連する機器どうし（ファ
イルサーバとクライアント群など）を一度に移行する必要があります。これは
トラブルを起こす可能性が高いため，移行が難しいという問題があります。

*** ②いきなり接続パターン

次のパターンは，我々がやったようにレガシーネットワークとOpenFlowネット
ワークをいきなりつなげてしまう方法です（図3）。

図3　レガシーネットワークとOpenFlowネットワークを直結してしまう

相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできま
す。このため，独立ネットワークパターンに比べて移行の手間はずっと小さい
と言えます。

OpenFlowネットワークのコントローラが完璧に作られていれば，このようにい
きなりつなげても問題はありませんが，完璧なテストというのは難しいです。
ユニットテストによって関数レベルで細かくテストすることもできますが（注
4），それだけでは不十分です。というのも，我々が失敗したように，生のトラ
フィックをコントローラに流し込んでみて初めて見つかるバグがあるからです。
よって，この方法は自宅ネットワークなど自由にいじれるネットワーク以外で
は推奨できません。

注4）第9回を参照。

*** ③逆流防止パターン

最後のパターンは，今までに挙げてきた2つのパターンのいいとこどりです。2
つのネットワークを接続するのですが，そのときに「逆流防止弁」を付けてパ
ケットの逆流が起きないようにします（図4）。

図4　レガシーネットワークとOpenFlowネットワークの間での逆流を防止する

たとえば，「レガシーネットワーク→OpenFlowネットワーク」のような一方向
のパケットは通しますが，同じパケットがレガシー側に戻ることを防ぎます。
逆方向でも同じです。

この方法の利点は，逆流を防ぐだけでかなりの障害を未然に防げることです。
また，使い勝手はいきなり接続した場合と同じなのでOpenFlowへの移行も楽で
す。

検討の結果，このパターンが一番良さそうでした。この逆流防止弁はOpenFlow
コントローラとして実装できそうです。前置きが長くなりましたが，さっそく
Tremaを使って実装してみましょう。

** 逆流防止弁

逆流防止弁は1つのpacket_inに対して2つのフローを設定します。1つは順方向
のフローで，入ってきたパケットをもう1つのスイッチポートに転送します。も
う1つは逆方向のフローで，同じパケットが逆方向に流れてきたときにこのパケッ
トを落とします。

*** 実装

逆流防止弁（OneWayBridgeコントローラ）のソースコードをリスト1に示します。
このコントローラは，packet_inとflow_removedのハンドラを定義しています。

#+BEGIN_SRC ruby
class OneWayBridge < Controller

  def packet_in datapath_id, message　← 順方向と逆方向のフローを設定する
    out_port = { 1 => 2, 2 => 1 }[ message.in_port ]
    add_flow datapath_id, message.macsa, message.in_port, out_port
    send_packet datapath_id, message, out_port
    add_drop_flow datapath_id, message.macsa, out_port
  end

  def flow_removed datapath_id, message　← 順方向と逆方向のフローのいずれかが消えたときに，もう1つも消す
    delete_flow datapath_id, message.match.dl_src
  end

  private　← 以下，プライベートメソッド

  def add_flow datapath_id, macsa, in_port, out_port　← 送信元MACアドレスがmacsaで，スイッチポートin_portからout_portへのフローを追加
    send_flow_mod_add(
      datapath_id,
      :idle_timeout => 10 * 60,
      :match => Match.new( :in_port => in_port, :dl_src => macsa ),
      :actions => ActionOutput.new( :port => out_port )
    )
  end

  def send_packet datapath_id, message, out_port　← パケットをスイッチポートout_portへ転送
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => ActionOutput.new( :port => out_port )
    )
  end

  def add_drop_flow datapath_id, macsa, in_port　← 逆流してきたパケットを落とすフローを追加（:actionsを指定していないので，マッチしたパケットを落とす）
    send_flow_mod_add(
      datapath_id,
      :idle_timeout => 10 * 60,
      :match => Match.new( :in_port => in_port, :dl_src => macsa )
    )
  end

  def delete_flow datapath_id, macsa　← 順方向と逆方向のフローを両方とも消す
    send_flow_mod_delete(
      datapath_id,
      :match => Match.new( :dl_src => macsa )
    )
  end
end
#+END_SRC

packet_inハンドラでは，packet_inしたスイッチポートとは別のポートへパケッ
トを転送するフロー（たとえば，スイッチポート1番から入ってきたパケットは
スイッチポート2番に転送するフロー）を設定し（add_flowメソッド），実際に
パケットを転送します（send_packetメソッド）。また，同じパケットが逆向き
に流れないようにするフローを設定することで逆流を防ぎます
（add_drop_flowメソッド）。

flow_removedハンドラは，順方向または逆方向のフローが消えたときに呼ばれ
ます。これらのフローはどちらもdl_srcに同じMACアドレスが指定されているの
で，delete_flowでもう片方を消します。なおここではやっていませんが，
flow_removed メッセージに乗ってくる統計情報（注5）を使って，逆流パケッ
トがあった場合には警告メッセージを出すようにするとさらに効果的でしょう。

注5）第8回の「トラフィック集計スイッチ」でこのテクニックを使いました。

*** 実行

それではさっそく実行してみましょう。実行のためには，レガシーネットワー
クとOpenFlowネットワークの間にOneWayBridgeコントローラで制御する仮想ス
イッチ（vswitch）をはさみます（図5）。vswitchのポートは，vswitchを実行
するマシンのNIC（eth0，eth1）に結び付けます。

図5　逆流防止弁（OneWayBridgeコントローラ）を実行するときの物理構成

図5の物理構成をTrema設定ファイルにしたものがリスト
2（one-way-bridge.conf）です。仮想リンク（link で始まる行）の端点にイン
ターフェース名eth0，eth1を指定していることに注目してください。

リスト2　逆流防止弁（OneWayBridgeコントローラ）の設定ファイル

#+BEGIN_SRC ruby
vswitch ( "bridge" ) {
  datapath_id 0xabc
}

link "bridge", "eth0"
link "bridge", "eth1"
#+END_SRC

実行するには，この設定ファイルをtrema runの-cオプションに渡します。

#+BEGIN_SRC
% ./trema run ./one-way-bridge.rb -c ./one-way-bridge.conf
#+END_SRC

*** 使ってみた

さっそくこの逆流防止弁を導入したところ，期待していたとおり，問題は起こ
らなくなりました。現在，OpenFlowスイッチ5台，ホスト約100台から構成され
るOpenFlowネットワークを職場ネットワークと接続して運用しています。もち
ろん，このOpenFlowネットワークはどんどん拡大しつつあり，ゆくゆくは職場
ネットワークを置き換える予定です。

** まとめ

職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました。今
回学んだことは次の2つです。

既存のレガシーネットワークをOpenFlowに移行するいくつかのパターンを見ま
した。自宅ネットワークなど自由にできるネットワークでは「いきなり接続パ
ターン」で十分ですが，職場ネットワークでは「逆流防止パターン」が最適で
す逆流防止弁を実現するOpenFlowコントローラを実装しました。基本的には2つ
のフローを設定するだけで，簡単に逆流を防止できます
