* Trema 入門
** OpenFlow プログラミングフレームワーク Trema
*** Trema のセットアップ
Trema は Linux 上で動作します。次のディストリビューションとバージョンで
の動作を保証しています。

 * Ubuntu 10.04 以降 (i386/amd64, デスクトップ版)
 * Debian GNU/Linux 6.0 (i386/amd64)

なお公式にサポートはしていませんが、RedHat などその他の代表的な Linux
ディストリビューションでも動作するはずです。本連載では、Ubuntu の最新バー
ジョンである 11.04 (デスクトップエディション 32 ビット版) を使います。

Trema の提供する trema コマンドの実行には root 権限が必要です。Trema は
内部的に、sudo コマンドを使って root 権限でいくつかのコマンドを実行しま
す。まずは、sudo コマンドを使って root 権限でコマンドを実行できるかどう
か、sudo の設定ファイルを確認してください。

sudo が正しく設定できていることを確認したら、Trema のインストールや実行
に必要ないくつかのソフトウェアをインストールしましょう。

 * Ruby インタプリタ。Trema は Ruby と C で作成されていて、アプリケーショ
   ンの記述にも Ruby を使います。Trema では Ruby のバージョン 1.8.7 が
   必要です。1.8.6 以前のバージョンやバージョン 1.9 以降では今のところ
   動作しません。
 * Ruby のパッケージ管理システム RubyGems (https://rubygems.org/)
 * Trema 本体。本書は、Trema バージョン 0.3.0 を使用して執筆しています。
 * Trema のコンパイルに必要な gcc や make、およびいくつかのライブラリ。

Trema の実行に必要なのはこれだけです。それでは、Ubuntu のパッケージ管理
システム apt-get を使って必要なパッケージを次のようにインストールしてく
ださい。もし他のディストリビューションを使いたい場合は、コマンド名とパッ
ケージ名を適宜読み替えください。

#+BEGIN_SRC
prompt> sudo apt-get install git gcc make ruby ruby-dev libpcap-dev libsqlite3-dev
#+END_SRC

以上で Trema をインストールするための準備が整いました。続いて Trema を
インストールするには、RubyGems のパッケージで手軽にインストールする方法
と、最新のソースコードを取得して自分でビルドする方法があります。それぞ
れ説明していきましょう。

**** パッケージで手軽にインストールする場合

Trema は RubyGems を使って次のようにコマンド一発で簡単にインストールできます。

#+BEGIN_SRC
prompt> gem install trema
#+END_SRC

RubyGems でインストールした場合、自動的に Trema のコマンド trema にパス
が通っているはずです。次のコマンドでバージョンが表示されればインストー
ルは成功です。

#+BEGIN_SRC
prompt> trema --version
trema version 0.3.0
#+END_SRC

**** ソースコードから最新版をインストールする場合

最新版をインストールしたい人は、GitHub から自分でソースコードをダウンロー
ドしてビルドすることもできます。まず、次のように git を使って最新のソー
スコードを取得してください。

#+BEGIN_SRC
prompt> git clone git://github.com/trema/trema.git
#+END_SRC

次のコマンドを実行すると、Trema が依存する RubyGems のパッケージが自動
的にインストールされます。

#+BEGIN_SRC
prompt> cd trema
prompt> gem install bundler
prompt> bundle install
#+END_SRC

次のコマンドで Trema をダウンロードしたディレクトリ以下に Trema がイン
ストールされます。make install のようなシステム全体へのインストール手順
は不要です。

#+BEGIN_SRC
prompt> ./build.rb
#+END_SRC

次のコマンドで trema コマンドが正しくインストールされたか確認してくださ
い。

#+BEGIN_SRC
prompt> ./trema --version
trema version 0.3.0
#+END_SRC

もし必要あればこのディレクトリにパスを通し、trema コマンドが簡単に起動
できるようにしておいてください。

さあ、これで Trema による OpenFlow 開発環境が整いました。それでは早速、
入門の定番 Hello, World を Trema で書いてみましょう。

*** Hello, Trema!
今から書くアプリケーションは最も簡単な OpenFlow コントローラの一種で、
画面に「 =Hello, Trema!= 」と表示するだけのものです。スイッチとはまった
くやりとりしないスタンドアロンのアプリケーションですが、Trema で作れる
コントローラの基本がすべて入っています。

では、適当なディレクトリにエディタで =hello-trema.rb= というファイルを
開き、次のコードを入力してください。"=.rb=" は Ruby プログラムの標準的
な拡張子です。なお Ruby の文法は必要に応じておいおい説明しますので、も
し分からなくても今のところは気にせずそのまま入力してください。

#+CAPTION: Hello Trema! コントローラ
#+name: src:hello
#+BEGIN_SRC ruby
  class HelloController < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

意味はまだわからないかもしれませんが、とてもシンプルに見えますね。それ
では細かい文法は後で見るとして「習うより慣れろ」でさっそく実行してみま
しょう。

**** 実行してみよう (trema run)

作成したコントローラは =trema run= コマンドですぐに実行できます。Rubyは
インタプリタ言語なので、コンパイルの必要はありません。ターミナルで次の
ように入力すると、この世界一短い OpenFlow コントローラはフォアグラウン
ドプロセスとして起動し、画面に =Hello, Trema!= と出力します。起動したコ
ントローラは =Ctrl + c= で停止できます。

#+BEGIN_SRC
prompt> cd trema
prompt> ./trema run ./hello-trema.rb
Hello, Trema!  # Ctrl-c で終了
prompt>
#+END_SRC

いかがでしょうか？ trema コマンドを使うと、とても簡単にコントローラを実
行できます。=trema= コマンドは Trema のコマンドラインツールであり、コン
トローラの起動やテストなど様々な用途に使います。たとえば先ほどの
「Hello Trema!」で見たように、 =trema run= はコントローラを起動するため
のコマンドです。起動したコントローラは OpenFlow スイッチと接続しメッセー
ジをやりとりします。

このコントローラは何もしてくれませんが、Trema でコントローラを書くのに
必要な知識がひととおり含まれています。スイッチをつなげるのはちょっと辛
抱して、まずはソースコードを見ていきましょう。

**** コントローラクラスを定義する
Ruby で書く場合、すべてのコントローラは Controller クラスを継承して定義
します ([[src:hello][リスト 1 (1)]])。

Controller クラスを継承することで、コントローラに必要な基本機能が
HelloController クラスにこっそりと追加されます。

**** ハンドラを定義する
Trema はイベントドリブンなプログラミングモデルを採用しています。つまり、
OpenFlow メッセージの到着など各種イベントに対応するハンドラを定義してお
くと、イベントの発生時に対応するハンドラが呼び出されます。たとえば
start メソッドを定義しておくと、コントローラの起動時にこれが自動的に呼
ばれます ([[src:hello][リスト 1 (2)]])。

さて、これで Trema の基本はおしまいです。次は、いよいよ実用的な
OpenFlow コントローラを書いて実際にスイッチをつないでみます。

*** スイッチモニタリングツール
次のお題はスイッチのモニタリングツールです。「今、ネットワーク中にどの
スイッチが動いているか」をリアルタイムに表示しますので、何らかの障害で
落ちてしまったスイッチを発見するのに便利です。

スイッチモニタリングツールは図 2 のように動作します。

OpenFlow スイッチは，起動すると OpenFlow コントローラへ接続しに行きます。
Trema では，スイッチとの接続が確立すると，コントローラの switch_ready
ハンドラが呼ばれます。コントローラはスイッチ一覧リストを更新し，新しく
起動したスイッチをリストに追加します。逆にスイッチが何らかの原因で接続
を切った場合，コントローラの `switch_disconnected` ハンドラが呼ばれます。
コントローラはリストを更新し，いなくなったスイッチをリストから削除しま
す。

**** 仮想ネットワーク

それでは早速，スイッチの起動を検知するコードを書いてみましょう。なんと，
Trema を使えば OpenFlow スイッチを持っていなくてもこうしたコードを実行
してテストできます。いったいどういうことでしょうか?

その答えは，Trema の強力な機能の 1 つ，仮想ネットワーク構築機能にありま
す。これは仮想 OpenFlow スイッチや仮想ホストを接続した仮想ネットワーク
を作る機能です。この仮想ネットワークとコントローラを接続することによっ
て，物理的な OpenFlow スイッチやホストを準備しなくとも，開発マシン 1 台
で OpenFlow コントローラと動作環境を一度に用意して開発できます。もちろ
ん，開発したコントローラは実際の物理的な OpenFlow スイッチやホストで構
成されたネットワークでもそのまま動作します!

それでは仮想スイッチを起動してみましょう。

**** 仮想 OpenFlow スイッチを起動する

仮想スイッチを起動するには，仮想ネットワークの構成を記述した設定ファイ
ルを `trema run` に渡します。たとえば，リスト 2 の設定ファイルでは仮想
スイッチ (`vswitch`) を 2 台定義しています。

#+BEGIN_SRC ruby
vswitch { datapath_id 0xabc }
vswitch { datapath_id 0xdef }
#+END_SRC

リスト2　仮想ネットワークに仮想スイッチを2台追加

それぞれに指定されている `datapath_id` (`0xabc`， `0xdef`) はネットワー
クカードにおける MAC アドレスのような存在で，スイッチを一意に特定する
ID として使われます。OpenFlow の規格によると，64 ビットの一意な整数値を
OpenFlow スイッチ 1 台ごとに割り振ることになっています。仮想スイッチで
は好きな値を設定できるので，かぶらないように適当な値をセットしてくださ
い。

#+BEGIN_SRC ruby
class SwitchMonitor < Controller
  periodic_timer_event :show_switches, 10 # (3)

  def start
    @switches = []
  end

  def switch_ready datapath_id # (1)
    @switches << datapath_id.to_hex
    info "Switch #{ datapath_id.to_hex } is UP"
  end

  def switch_disconnected datapath_id # (2)
    @switches -= [datapath_id.to_hex ]
    info "Switch #{ datapath_id.to_hex } is DOWN"
  end

  private # (3)
  def show_switches
    info "All switches = " + @switches.sort.join( ", " )
  end
end
#+END_SRC

リスト3　SwitchMonitor コントローラ

それでは，さきほど定義したスイッチを起動してコントローラから捕捉してみ
ましょう。スイッチの起動イベントを捕捉するには `switch_ready` ハンドラ
を書きます (リスト 3-1)。

`@switches` は現在起動しているスイッチのリストを管理するインスタンス変
数で，新しくスイッチが起動するとスイッチの `datapath_id` が追加されます。
また，`puts` メソッドで `datapath_id` を表示します。

**** スイッチの切断を捕捉する

同様に，スイッチが落ちて接続が切れたイベントを捕捉してみましょう。この
ためのハンドラは `switch_disconnected` です (リスト 3-2)。

スイッチの切断を捕捉すると，切断したスイッチの `datapath_id` をスイッチ
一覧 `@switches` から除きます。また，`datapath_id` を `puts` メソッドで
表示します。

**** スイッチの一覧を表示する

最後に，スイッチの一覧を定期的に表示する部分を作ります。一定時間ごとに
何らかの処理を行いたい場合には，タイマー機能を使います。リスト 3-3 のよ
うに，一定の間隔で呼びたいメソッドと間隔 (秒数) を
`periodic_timer_event` で指定すると，指定されたメソッドが呼ばれます。こ
こでは，スイッチの一覧を表示するメソッド `show_switches` を 10 秒ごとに
呼び出します。

**** 実行

それでは早速実行してみましょう。仮想スイッチを 3 台起動する場合，リスト
4 の内容のファイルを `switch-monitor.conf` として保存し，設定ファイルを
`trema run` の `-c` オプションに渡してください。

#+BEGIN_SRC ruby
vswitch { datapath_id 0x1 }
vswitch { datapath_id 0x2 }
vswitch { datapath_id 0x3 }
#+END_SRC

リスト4　仮想スイッチを3台定義

実行結果は次のようになります。

#+BEGIN_SRC
    % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
    Switch 0x3 is UP
    Switch 0x2 is UP
    Switch 0x1 is UP
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    ……
#+END_SRC

`switch-monitor` コントローラが起動すると設定ファイルで定義した仮想スイッ
チ 3 台が起動し，`switch-monitor` コントローラの `switch_ready` ハンド
ラによって捕捉され，このメッセージが出力されました。

それでは，スイッチの切断がうまく検出されるか確かめてみましょう。スイッ
チを停止するコマンドは `trema kill` です。別ターミナルを開き，次のコマ
ンドでスイッチ `0x3` を落としてみてください。

#+BEGIN_SRC
    % ./trema kill 0x3
#+END_SRC

すると，`trema run` を動かしたターミナルに次の出力が表示されているはず
です。

#+BEGIN_SRC
    % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
    Switch 0x3 is UP
    Switch 0x2 is UP
    Switch 0x1 is UP
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    ……
    Switch 0x3 is DOWN
#+END_SRC

うまくいきました! おわかりのとおり，このメッセージは
`switch_disconnected` ハンドラによって表示されたものです。

**** 友太郎の質問 datapath ってなに?

Q. 「こんにちは! 僕は最近 OpenFlow に興味を持ったプログラマ，友太郎です。
   スイッチに付いている ID を datapath ID って呼ぶのはわかったけど，いっ
   たい datapath ってなに? スイッチのこと?」

A. 実用的には 「datapath = OpenFlow スイッチ」 と考えて問題ありません。

「データパス」 でググると，「CPUは演算処理を行うデータパスと，指示を出
すコントローラから構成されます」 というハードウェア教科書の記述がみつか
ります。つまり，ハードウェアの世界では一般に 「筋肉にあたる部分 = デー
タパス」「脳にあたる部分 = コントローラ」 という分類をするようです。

OpenFlow の世界でも同じ用法が踏襲されています。OpenFlow のデータパスは
パケット処理を行うスイッチを示し，その制御を行うソフトウェア部分をコン
トローラと呼びます。

** まとめ

すべてのコントローラのテンプレートとなる Hello, Trema! コントローラを書
きました。また，これを改造してスイッチの動作状況を監視するスイッチモニ
タを作りました。学んだことは次の3つです。

- OpenFlow ネットワークはパケットを処理するスイッチ (datapath) と，スイッ
  チを制御するソフトウェア (コントローラ) から構成される。Trema は，こ
  のコントローラを書くためのプログラミングフレームワークである
- Trema は仮想ネットワーク構築機能を持っており，OpenFlow スイッチを持っ
  ていなくてもコントローラの開発やテストが可能。たとえば，仮想ネットワー
  クに仮想スイッチを追加し，任意の datapath ID を設定できる
- コントローラは Ruby の Controller クラスを継承し，OpenFlow の各種イベ
  ントに対応するハンドラを定義することでスイッチをコントロールできる。
  たとえば，`switch_ready` と `switch_disconnected` ハンドラでスイッチ
  の起動と切断イベントに対応するアクションを書ける

次回はいよいよ本格的なコントローラとして，トラフィック集計機能のあるレ
イヤ 2 スイッチを作ります。初歩的なレイヤ 2 スイッチング機能と，誰がど
のくらいネットワークトラフィックを発生させているかを集計する機能を
OpenFlow で実現します。

**** 友太郎の質問: `switch_ready` ってなに ?

Q. 「OpenFlow の仕様を読んでみたけど，どこにも `switch_ready` って出て
   こなかったよ? OpenFlow にそんなイベントが定義されてるの?」

A. `switch_ready` は Trema 独自のイベントで，スイッチが Trema に接続し
   指示が出せるようになった段階でコントローラに送られます。実は，
   `switch_ready` の裏では図 A の一連の処理が行われており，Trema が
   OpenFlow プロトコルの詳細をうまくカーペットの裏に隠してくれているの
   です。

図A　switch_ready イベントが起こるまで

最初に，スイッチとコントローラがしゃべる OpenFlow プロトコルが合ってい
るか確認します。OpenFlow の `HELLO` メッセージを使ってお互いのプロトコ
ルバージョンを確認し，うまく会話できそうか確認します。

次は，スイッチを識別するための datapath ID の取得です。datapath ID のよ
うなスイッチ固有の情報は，スイッチに対して OpenFlow の Features
Request メッセージを送ることで取得できます。成功した場合，datapath ID
やポート数などの情報が Features Reply メッセージに乗ってやってきます。

最後にスイッチを初期化します。スイッチに以前の状態が残っていると，コン
トローラが管理する情報と競合が起こるため，初期化することでこれを避けま
す。これら一連の処理が終わると，ようやく `switch_ready` がコントローラ
に通知されます。
