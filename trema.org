* 2 分でわかる! OpenFlow と SDN の基本
2013 年は OpenFlow や SDN (Software Defined Networking) という用語が急激に浸透した年でした. 2014 年に入った今でも, 毎日のように雑誌やネットで OpenFlow 関係の記事を見かけます.

しかしある意味バズワード的な流行だったため, 多くの人にきちんと理解されていないことも事実です. よく目にする 「OpenFlow はなんでもできる」という売り文句もあいまいでよく分かりませんし, 話題に追い付こうとする間にも新しい専門用語がどんどん登場します. さらに「大手○○社も OpenFlow に参入!」のようなニュース記事からの情報もごっちゃになって, もう何が何だか…と混乱している人も多いでしょう.

** 基本はシンプル!
派手な宣伝文句や専門用語をいったん差し置いてしまえば, 実は OpenFlow の基本はいたってシンプルです. OpenFlow を一言で言えば,「ネットワークスイッチを制御するための標準プロトコルの一種」です[fn:onf]. OpenFlow 自体は複雑怪奇なシステムではなく, 実体はただのプロトコル定義なのです. このプロトコルができることもシンプルで, スイッチの内部動作を書き換えるというものです (ただし,スイッチが OpenFlow プロトコルに対応している必要があります).

OpenFlow では, このスイッチを制御する部分を「コントローラ」と呼ばれるソフトウェアとして実装します. コントローラは OpenFlow プロトコルを実装したデーモンの一種で, 何台もの OpenFlow スイッチをまとめて制御できます (図 [[fig:openflow_controller]]). よく聞く「OpenFlow ではソフトウェアでネットワークを定義できる」「分散ではなく集中的に管理できる」などのうたい文句はこの仕組みから来ています.

#+CAPTION: OpenFlow スイッチとコントローラの関係
#+NAME: fig:openflow_controller
[[./images/openflow_controller.png]]

コントローラが変更できるスイッチの内部動作は, スイッチの根本的な機能にまで及びます. たとえばスイッチのパケット転送ルールを書き換えてロードバランサやファイヤウォールに変身させるなど,基本動作のレベルからいかようにでも変更できてしまいます. 従来こうした変更にはファームウェアの改造が必要でしたので, それと比べると格段の進歩です. これが「なんでもできる」と宣伝されている理由です.

[fn:onf] OpenFlow の詳しい仕様書や標準化に関する情報は, Open Networking Foundation のサイト (https://www.opennetworking.org/) で入手できます.

** 「なんでもできる」のメリット
この「なんでもできる」という特徴は実は, ネットワーク管理者よりもむしろサーバ管理者やプログラマにとってうれしいものです.

OpenFlow を使うとサーバ構築が楽になります. 従来のスイッチでは, 同じ IP アドレスのサーバをつなげると正しく通信できませんでした. このためたとえばロードバランサのバックエンドサーバは, ソフトウェア構成は同じでも IP アドレスだけを変える必要があり, 構築がちょっと面倒でした. しかし OpenFlow では, IP アドレスが同じでも通信できる特別なスイッチを作れます (図 [[fig:backend_server]]). このおかげでバックエンドサーバーをすべてまったく同じにできるので, コピーするだけでバックエンドサーバをいくつでも増やせるようになります.

#+CAPTION: OpenFlow を使うとバックエンドサーバをまったく同じにできる
#+NAME: fig:backend_server
[[./images/backend_server.png]]

OpenFlow はプログラマにとっても「なんでもできる」世界です. OpenFlow は結局のところただのプロトコル仕様なので, 好きなプログラミング言語で実装できます. たとえば後に紹介する Trema は Ruby 用の OpenFlow ライブラリを提供していますし, そのほかにも Java や Python, Haskell など主要な言語向けのライブラリがすでに揃っています. プログラマやチームの好みに合わせて使う言語を自由に選び, ネットワークを根本からプログラミングできるのです.

** データセンターをプログラミングする
さまざまな言語の豊富なライブラリが使えるので, OpenFlow は外部のソフトウェアと簡単に連携できます. たとえば memcached や Redis のライブラリを使ってスイッチのデータベースを分散化したり, ログインサービスなどのミドルウェアと連携してネットワークに認証機能を付け加える, などといったことも OpenFlow はお手のものです.

OpenFlow を既存のミドルウェアと連携すれば, IT システム全体をソフトウェアで制御できるようになります. たとえば Google などの巨大データセンターではすでに大量のサーバをミドルウェアで制御できていますから, OpenFlow で制御したネットワークと連携してやればデータセンター全体をすべてソフトウェアで制御できることになります (図 [[fig:datacenter_sdn]]). Google が提唱した「コンピューターとしてのデータセンター」という言葉が表すように, SDN によってデータセンター全体をひとつのコンピュータとしてプログラミングできるようになるのです.

#+CAPTION: SDN でデータセンター全体をソフトウェア制御できる
#+NAME: fig:datacenter_sdn
[[./images/datacenter_sdn.png]]

すこし大規模な話になりましたが, これで OpenFlow や SDN のポイントが分かっていただけたでしょうか. 続く実践編は OpenFlow プログラミングを手軽に始めてみようというチュートリアルとなっています. 職場や自宅のような中小規模ネットワークでもすぐに試せる実用的なコードを通じて, 「OpenFlow ってどんな仕様？」「どうやってプログラムを書けばいいの？」という疑問に答えていきます. OpenFlow プログラミングに必要なネットワークの基礎から説明しますので, 普通のプログラマもすんなりと理解できるはずです.

まずは, OpenFlow プログラミングのためのフレームワーク「Trema（トレマ）」を紹介します.

* Trema 入門
Trema は OpenFlow コントローラを開発するための Ruby 用プログラミングフレームワークです.Tremaは「OpenFlow 界の Rails」をうたっており,ノート PC 1 台でアジャイルに OpenFlow 開発できる環境を提供しています.Trema は GitHub 上で開発されており,GPLv2 ライセンスのフリーソフトウェアです.公開は今年の 4 月と非常に新しいソフトウェアですが,その使いやすさから国内外の大学や企業および研究機関などですでに採用されています.

Tremaの情報は次のサイトから入手できます.

- Trema ホームページ: https://trema.github.io/trema/
- GitHub のプロジェクトページ: https://github.com/trema/trema
- メーリングリスト: https://groups.google.com/forum/#!forum/trema-dev
- Twitterアカウント：https://twitter.com/trema_news

Trema を使うと,ノート PC 1 台で OpenFlow コントローラの開発を始められます.それでは早速 Trema をセットアップして,簡単なプログラムを書いてみましょう.

** Trema のセットアップ
Trema は Linux 上で動作します.次のディストリビューションとバージョンでの動作を保証しています.

- Ubuntu (i386/amd64, デスクトップ版)
- Debian GNU/Linux (i386/amd64)

なお公式にサポートはしていませんが,RedHat などその他の代表的な Linux ディストリビューションでも動作するはずです.

Trema の提供する =trema= コマンドの実行には root 権限が必要です.Trema は内部的に, =sudo= コマンドを使って root 権限でいくつかのコマンドを実行します.まずは =sudo ls= などとして root 権限でコマンドを実行できるかどうか確認してください.

sudo が正しく設定できていることを確認したら,Trema のインストールや実行に必要ないくつかのソフトウェアをインストールしましょう.

- Ruby インタプリタ.Trema は Ruby と C で作成されていて,アプリケーションの記述には Ruby を使います.Trema では Ruby のバージョン 2.0.0 以上が必要です.
- Ruby のパッケージ管理システム RubyGems (https://rubygems.org/)
- Trema 本体
- Trema のコンパイルに必要な gcc や make,およびいくつかのライブラリ

Trema の実行に必要なのはこれだけです.それでは,Ubuntu のパッケージ管理システム =apt-get= を使って必要なパッケージを次のようにインストールしてください.もし他のディストリビューションを使いたい場合は,コマンド名とパッケージ名を適宜読み替えください.

#+BEGIN_SRC
prompt> sudo apt-get install gcc make git ruby rubygems ruby-dev libpcap-dev libsqlite3-dev libglib2.0-dev
#+END_SRC

以上で Trema をインストールするための準備が整いました.続いて Trema をインストールするには,RubyGems のパッケージで手軽にインストールする方法と,最新のソースコードを取得して自分でビルドする方法があります.それぞれ説明していきましょう.

*** パッケージで手軽にインストールする場合
Trema は RubyGems を使って次のようにコマンド一発で簡単にインストールできます.

#+BEGIN_SRC
prompt> gem install trema
#+END_SRC

RubyGems でインストールした場合,自動的に Trema のコマンド =trema= にパスが通っているはずです.次のコマンドでバージョンが表示されればインストールは成功です.

#+BEGIN_SRC
prompt> trema --version
trema version 0.4.6
#+END_SRC

*** ソースコードから最新版をインストールする場合
最新版をインストールしたい人は,GitHub から自分でソースコードをダウンロードしてビルドすることもできます.まず,次のように git を使って最新のソースコードを取得してください.

#+BEGIN_SRC
prompt> git clone git://github.com/trema/trema.git
#+END_SRC

次のコマンドを実行すると,Trema が依存する RubyGems のパッケージが自動的にインストールされます.

#+BEGIN_SRC
prompt> cd trema
prompt> gem install bundler
prompt> bundle install
#+END_SRC

次のコマンドで Trema をダウンロードしたディレクトリ以下に Trema がインストールされます.make install のようなシステム全体へのインストール手順は不要です.

#+BEGIN_SRC
prompt> ./build.rb
#+END_SRC

次のコマンドで trema コマンドが正しくインストールされたか確認してください.

#+BEGIN_SRC
prompt> ./trema --version
trema version 0.4.6
#+END_SRC

もし必要あればこのディレクトリにパスを通し,trema コマンドが簡単に起動できるようにしておいてください.

さあ,これで Trema による OpenFlow 開発環境が整いました.それでは早速,入門の定番 Hello, World を Trema で書いてみましょう.

** Hello, Trema!
今から書くアプリケーションは最も簡単な OpenFlow コントローラの一種で,画面に =Hello, Trema!= と表示するだけのものです.スイッチとはまったくやりとりしないスタンドアロンのアプリケーションですが,Trema で作れるコントローラの基本がすべて入っています.

では,適当なディレクトリにエディタで =hello-trema.rb= というファイルを開き,次のコードを入力してください."=.rb=" は Ruby プログラムの標準的な拡張子です.なお Ruby の文法は必要に応じておいおい説明しますので,もし分からなくても今のところは気にせずそのまま入力してください.

#+CAPTION: Hello Trema! コントローラ
#+name: src:hello
#+BEGIN_SRC ruby
  class HelloController < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

意味はまだわからないかもしれませんが,とてもシンプルに見えますね.それでは細かい文法は後で見るとして「習うより慣れろ」でさっそく実行してみましょう.

*** 実行してみよう (trema run)
作成したコントローラは =trema run= コマンドですぐに実行できます.Ruby はインタプリタ言語なので,コンパイルの必要はありません.ターミナルで次のように入力すると,この世界一短い OpenFlow コントローラはフォアグラウンドプロセスとして起動し,画面に =Hello, Trema!= と出力します.起動したコントローラは =Ctrl + c= で停止できます.

#+BEGIN_SRC
prompt> cd trema
prompt> ./trema run ./hello-trema.rb
Hello, Trema!  # Ctrl-c で終了
prompt>
#+END_SRC

いかがでしょうか？ trema コマンドを使うと,とても簡単にコントローラを実行できます.=trema= コマンドは Trema のコマンドラインツールであり,コントローラの起動やテストなど様々な用途に使います.たとえば先ほどの「Hello Trema!」で見たように, =trema run= はコントローラを起動するためのコマンドです.起動したコントローラは OpenFlow スイッチと接続しメッセージをやりとりします.

このコントローラは何もしてくれませんが,Trema でコントローラを書くのに必要な知識がひととおり含まれています.スイッチをつなげるのはちょっと辛抱して,まずはソースコードを見ていきましょう.

*** コントローラクラスを定義する
Ruby で書く場合,すべてのコントローラは Controller クラスを継承して定義します.

#+BEGIN_SRC ruby
  class HelloController < Controller
#+END_SRC

Controller クラスを継承することで,コントローラに必要な基本機能が HelloController クラスにこっそりと追加されます.

*** ハンドラを定義する
Trema はイベントドリブンなプログラミングモデルを採用しています.つまり,OpenFlow メッセージの到着など各種イベントに対応するハンドラを定義しておくと,イベントの発生時に対応するハンドラが呼び出されます.たとえば start メソッドを定義しておくと,コントローラの起動時にこれが自動的に呼ばれます.

#+BEGIN_SRC ruby
    def start
      puts "Hello, Trema!"
    end
#+END_SRC

さて,これで Trema の基本はおしまいです.次は,いよいよ実用的な OpenFlow コントローラを書いて実際にスイッチをつないでみます.

** スイッチモニタリングツール
次の例はスイッチのモニタリングツールです.「今,ネットワーク中にどのスイッチが動いているか」をリアルタイムに表示しますので,何らかの障害で落ちてしまったスイッチを発見するのに便利です.

スイッチモニタリングツールは図 [[fig:switch_monitoring_tool]] のように動作します.

#+CAPTION: スイッチモニタリングツールの動作
#+NAME: fig:switch_monitoring_tool
[[./images/switch_monitoring_tool.png]]

OpenFlow スイッチは,起動すると OpenFlow コントローラへ接続しに行きます.Trema では,スイッチとの接続が確立すると,コントローラの =switch_ready= ハンドラが呼ばれます.コントローラはスイッチ一覧リストを更新し,新しく起動したスイッチをリストに追加します.逆にスイッチが何らかの原因で接続を切った場合,コントローラの =switch_disconnected= ハンドラが呼ばれます.コントローラはリストを更新し,いなくなったスイッチをリストから削除します.

*** 仮想ネットワーク
それでは早速,スイッチの起動を検知するコードを書いてみましょう.なんと,Trema を使えば OpenFlow スイッチを持っていなくてもこうしたコードを実行してテストできます.いったいどういうことでしょうか?

その答えは,Trema の強力な機能の 1 つ,仮想ネットワーク構築機能にあります.これは仮想 OpenFlow スイッチや仮想ホストを接続した仮想ネットワークを作る機能です.この仮想ネットワークとコントローラを接続することによって,物理的な OpenFlow スイッチやホストを準備しなくとも,開発マシン 1 台で OpenFlow コントローラと動作環境を一度に用意して開発できます.もちろん,開発したコントローラは実際の物理的な OpenFlow スイッチやホストで構成されたネットワークでもそのまま動作します!

それでは仮想スイッチを起動してみましょう.

*** 仮想 OpenFlow スイッチを起動する
仮想スイッチを起動するには,仮想ネットワークの構成を記述した設定ファイルを `trema run` に渡します.たとえば,[[list:two_switches]] の設定ファイルでは仮想スイッチ (=vswitch=) を 2 台定義しています.

#+CAPTION: 仮想ネットワークに仮想スイッチを2台追加
#+NAME: list:two_vswitches
#+BEGIN_SRC ruby
vswitch { datapath_id 0xabc }
vswitch { datapath_id 0xdef }
#+END_SRC

それぞれに指定されている =datapath_id= (=0xabc=, =0xdef=) はネットワークカードにおける MAC アドレスのような存在で,スイッチを一意に特定する ID として使われます.OpenFlow の規格によると,64 ビットの一意な整数値を OpenFlow スイッチ 1 台ごとに割り振ることになっています.仮想スイッチでは好きな値を設定できるので,かぶらないように適当な値をセットしてください.

#+CAPTION: SwitchMonitor コントローラ
#+BEGIN_SRC ruby
  class SwitchMonitor < Controller
    periodic_timer_event :show_switches, 10 # (3)

    def start
      @switches = []
    end

    def switch_ready datapath_id # (1)
      @switches << datapath_id.to_hex
      info "Switch #{ datapath_id.to_hex } is UP"
    end

    def switch_disconnected datapath_id # (2)
      @switches -= [datapath_id.to_hex ]
      info "Switch #{ datapath_id.to_hex } is DOWN"
    end

    private # (3)
    def show_switches
      info "All switches = " + @switches.sort.join( ", " )
    end
  end
#+END_SRC

それでは,さきほど定義したスイッチを起動してコントローラから捕捉してみましょう.スイッチの起動イベントを捕捉するには =switch_ready= ハンドラを書きます (リスト 3-1).

=@switches= は現在起動しているスイッチのリストを管理するインスタンス変数で,新しくスイッチが起動するとスイッチの =datapath_id= が追加されます.また, =puts= メソッドで =datapath_id= を表示します.

*** スイッチの切断を捕捉する
同様に,スイッチが落ちて接続が切れたイベントを捕捉してみましょう.このためのハンドラは =switch_disconnected= です (リスト 3-2).

スイッチの切断を捕捉すると,切断したスイッチの =datapath_id= をスイッチ一覧 =@switches= から除きます.また, =datapath_id= を =puts= メソッドで表示します.

*** スイッチの一覧を表示する
最後に,スイッチの一覧を定期的に表示する部分を作ります.一定時間ごとに何らかの処理を行いたい場合には,タイマー機能を使います.リスト 3-3 のように,一定の間隔で呼びたいメソッドと間隔 (秒数) を =periodic_timer_event= で指定すると,指定されたメソッドが呼ばれます.ここでは,スイッチの一覧を表示するメソッド =show_switches= を 10 秒ごとに呼び出します.

*** 実行
それでは早速実行してみましょう.仮想スイッチを 3 台起動する場合,リスト 4 の内容のファイルを =switch-monitor.conf= として保存し,設定ファイルを =trema run= の =-c= オプションに渡してください.

#+CAPTION: 仮想スイッチを3台定義
#+BEGIN_SRC ruby
vswitch { datapath_id 0x1 }
vswitch { datapath_id 0x2 }
vswitch { datapath_id 0x3 }
#+END_SRC

実行結果は次のようになります.

#+BEGIN_SRC
prompt> ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
Switch 0x3 is UP
Switch 0x2 is UP
Switch 0x1 is UP
All switches = 0x1, 0x2, 0x3
All switches = 0x1, 0x2, 0x3
All switches = 0x1, 0x2, 0x3
……
#+END_SRC

=switch-monitor= コントローラが起動すると設定ファイルで定義した仮想スイッチ 3 台が起動し, =switch-monitor= コントローラの =switch_ready= ハンドラによって捕捉され,このメッセージが出力されました.

それでは,スイッチの切断がうまく検出されるか確かめてみましょう.スイッチを停止するコマンドは =trema kill= です.別ターミナルを開き,次のコマンドでスイッチ =0x3= を落としてみてください.

#+BEGIN_SRC
prompt> ./trema kill 0x3
#+END_SRC

すると, =trema run= を動かしたターミナルに次の出力が表示されているはずです.

#+BEGIN_SRC
prompt> ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
Switch 0x3 is UP
Switch 0x2 is UP
Switch 0x1 is UP
All switches = 0x1, 0x2, 0x3
All switches = 0x1, 0x2, 0x3
All switches = 0x1, 0x2, 0x3
……
Switch 0x3 is DOWN
#+END_SRC

うまくいきました! おわかりのとおり,このメッセージは =switch_disconnected= ハンドラによって表示されたものです.

*** 友太郎の質問 datapath ってなに?

Q. 「こんにちは! 僕は最近 OpenFlow に興味を持ったプログラマ,友太郎です.
   スイッチに付いている ID を datapath ID って呼ぶのはわかったけど,いっ
   たい datapath ってなに? スイッチのこと?」

A. 実用的には 「datapath = OpenFlow スイッチ」 と考えて問題ありません.

「データパス」 でググると,「CPUは演算処理を行うデータパスと,指示を出
すコントローラから構成されます」 というハードウェア教科書の記述がみつか
ります.つまり,ハードウェアの世界では一般に 「筋肉にあたる部分 = デー
タパス」「脳にあたる部分 = コントローラ」 という分類をするようです.

OpenFlow の世界でも同じ用法が踏襲されています.OpenFlow のデータパスは
パケット処理を行うスイッチを示し,その制御を行うソフトウェア部分をコン
トローラと呼びます.

** まとめ
すべてのコントローラのテンプレートとなる Hello, Trema! コントローラを書きました.また,これを改造してスイッチの動作状況を監視するスイッチモニタを作りました.学んだことは次の3つです.

- OpenFlow ネットワークはパケットを処理するスイッチ (datapath) と,スイッチを制御するソフトウェア (コントローラ) から構成される.Trema は, このコントローラを書くためのプログラミングフレームワークである
- Trema は仮想ネットワーク構築機能を持っており,OpenFlow スイッチを持っていなくてもコントローラの開発やテストが可能.たとえば,仮想ネットワークに仮想スイッチを追加し,任意の datapath ID を設定できる
- コントローラは Ruby の Controller クラスを継承し,OpenFlow の各種イベントに対応するハンドラを定義することでスイッチをコントロールできる. たとえば,`switch_ready` と `switch_disconnected` ハンドラでスイッチの起動と切断イベントに対応するアクションを書ける

次回はいよいよ本格的なコントローラとして,トラフィック集計機能のあるレイヤ 2 スイッチを作ります.初歩的なレイヤ 2 スイッチング機能と,誰がどのくらいネットワークトラフィックを発生させているかを集計する機能を OpenFlow で実現します.

*** 友太郎の質問: `switch_ready` ってなに ?

Q. 「OpenFlow の仕様を読んでみたけど,どこにも `switch_ready` って出て
   こなかったよ? OpenFlow にそんなイベントが定義されてるの?」

A. `switch_ready` は Trema 独自のイベントで,スイッチが Trema に接続し
   指示が出せるようになった段階でコントローラに送られます.実は,
   `switch_ready` の裏では図 A の一連の処理が行われており,Trema が
   OpenFlow プロトコルの詳細をうまくカーペットの裏に隠してくれているの
   です.

図A　switch_ready イベントが起こるまで

最初に,スイッチとコントローラがしゃべる OpenFlow プロトコルが合ってい
るか確認します.OpenFlow の `HELLO` メッセージを使ってお互いのプロトコ
ルバージョンを確認し,うまく会話できそうか確認します.

次は,スイッチを識別するための datapath ID の取得です.datapath ID のよ
うなスイッチ固有の情報は,スイッチに対して OpenFlow の Features
Request メッセージを送ることで取得できます.成功した場合,datapath ID
やポート数などの情報が Features Reply メッセージに乗ってやってきます.

最後にスイッチを初期化します.スイッチに以前の状態が残っていると,コン
トローラが管理する情報と競合が起こるため,初期化することでこれを避けま
す.これら一連の処理が終わると,ようやく `switch_ready` がコントローラ
に通知されます.

* OpenFlow 入門
今回は盛りだくさんです！ まずは身近な例を使って,OpenFlow の動作モデル
を説明します.これが理解できれば,OpenFlow の基本概念はバッチリです.次
に,「トラフィック集計付きスイッチ」 を実現するコントローラを実際に作り
ます.これは OpenFlow の重要な処理をすべて含んでいるので,応用するだけ
でさまざまなタイプのコントローラが作れるようになります.最後に,作成し
たコントローラを Trema の仮想ネットワーク上で実行します.すばらしいこと
に,Trema を使えば開発から動作テストまでを開発マシン 1 台だけで完結でき
ます！

では前置きはこのぐらいにして,まずは OpenFlow でスイッチを制御するしく
みを理解しましょう.

*** OpenFlow の動作モデル

OpenFlow の動作を現実世界にたとえると,製品の電話サポートサービスに似て
います.

**** 電話サポートの業務手順

友太郎 (ゆうたろう) 君は,エアコンが故障したので修理に出そうと考えまし
た （図1）.電話サポートに問い合わせると,サポート係の葵 （あおい） さ
んはエアコンの症状を聞き,手元のマニュアルに対処方法が載っている場合に
はこれをすぐに教えてくれます.問題は,マニュアルに対処法が載っていない
場合です.このようなときは少し時間がかかりますが,上司の宮坂主任にどう
したらよいか聞きます.そして,宮坂主任からの回答が得られたら,葵さんは
友太郎君に折り返し電話をします.また,次からの同じ問い合わせにはすばや
く答えられるようにするため,葵さんは教わった対処法を手元のマニュアルに
追加しておきます.

簡単ですね？ 信じられないかもしれませんが,あなたはすでに OpenFlow の
95% を理解したも同然なのです.

![電話サポートの業務手順](https://github.com/trema/Programming-Trema/raw/master/images/2_001.png)

図1　電話サポートの業務手順

**** OpenFlowに置き換えると……

OpenFlow では,お客さんがパケットを発生させるホスト,電話サポート係がス
イッチ,上司がコントローラ,マニュアルがスイッチのフローテーブル (後述)
に対応します （図2）.

![OpenFlowの動作モデル](https://github.com/trema/Programming-Trema/raw/master/images/2_002.png)

図2　OpenFlowの動作モデル

スイッチはホストからのパケットを受信すると,最初はその処理方法がわかり
ません.そこで,上司にあたるコントローラに問い合わせます.この問い合わ
せを `packet_in` メッセージと呼びます.コントローラはこれを受け取ると,
同様のパケットが届いた場合にスイッチでどう処理すべきか (パケットを転送
する,書き換えるなど) を決めます.これをアクションと呼びます.そして
「スイッチで処理すべきパケットの特徴」＋「アクション」 の組 （フローと
呼びます） をスイッチのマニュアルに追加します.この命令を `flow_mod` メッ
セージと呼び,スイッチのマニュアルをフローテーブルと呼びます.処理すべ
きパケットの特徴とアクションをフローテーブルに書いておくことで,以後,
これに当てはまるパケットはスイッチ側だけですばやく処理できます.忘れて
はならないのが,`packet_in` メッセージで上がってきた最初のパケットです.
これはコントローラに上がってきて処理待ちの状態になっているので,
`packet_out` メッセージで適切な宛先に転送してあげます.

電話サポートとの大きな違いは,フローテーブルに書かれたフローには期限が
あり,これを過ぎると消えてしまうということです.これは,「マニュアルに
書かれた内容は徐々に古くなるので,古くなった項目は消す必要がある」 と考
えるとわかりやすいかもしれません.フローが消えるタイミングでコントロー
ラには `flow_removed` メッセージが送信されます.これには,あるフローに
従ってパケットがどれだけ転送されたか -- 電話サポートの例で言うと,マニュ
アルのある項目が何回参照されたか -- つまり,トラフィックの集計情報が記
録されています.

それではしくみの話はこのぐらいにして,早速実践に移りましょう.もし途中
でわからなくなったら,この節の頭から読み直してください.
* すべての基本,ラーニングスイッチを作ろう
** ラーニングスイッチとは何か？
OpenFlow の世界では,コントローラとしてソフトウェア実装したスイッチをよ
くラーニングスイッチと呼びます.なぜ,ラーニング (学習) スイッチと呼ぶ
のでしょうか？それは,スイッチが次のような仕組みで動くからです.

1. 学習: ホストから出たパケットに含まれる,ネットワーク上でのホストの位
   置情報を学習する
2. 転送: 今まで学習してきた位置情報を使って,パケットを宛先のホストまで
   転送する

この「学習し,転送する」というラーニングスイッチの仕組みは応用が広く効
きます.たとえば OpenFlow を使った大規模データセンターネットワークも,
基本はラーニングスイッチと同じく「学習し,転送する」という動作をします.
自宅ネットワークであろうが最新鋭のデータセンターであろうが,その基本的
な考えかたは同じなのです.

このおかげで,ラーニングスイッチを作れるようになれば,それを改造するこ
とでいろいろなアプリケーションを作れるようになります.

- トラフィックモニタ (この章で紹介)
- 複数スイッチ対応ラーニングスイッチ(Tremaのサンプルアプリの1つ)
- ルーティングスイッチ(Trema 本○○章で紹介)

ではさっそく,ネットワークの基本部品であるラーニングスイッチを Trema で
実装してみましょう.まずは一般的なハードウェアスイッチの動作原理を理解
し,次に OpenFlow での実現方法を見ていきます.

*** スイッチの仕組み
簡単なネットワークを例にしてスイッチの動作を説明します
([[fig:switch_network]]).スイッチのポート1番と4番に,ホスト1と2をそれぞれ
接続しています.また,それぞれのホストのネットワークカードは図に示した
MACアドレスを持つとします.

スイッチはホストから届いたパケットを宛先のホストまで転送するために,ス
イッチにつながる各ホストの位置情報をためておくデータベースを持っていま
す.これをフォワーディングデータベース(FDB)と呼び,「ホストのMACアドレ
ス+ポート番号」の組を保持します.

#+CAPTION: スイッチ1台とホスト2台からなるネットワークと,スイッチのFDBの内容
#+NAME: fig:switch_network
[[./images/switch_network.png]]

ここでホスト2がホスト1へパケットを送信すると,スイッチは次のようにパケッ
トをホスト1まで転送します([[fig:host2to1]]).

#+CAPTION: FDB の情報からパケットをホスト 1 に届ける
#+NAME: fig:host2to1
[[./images/host2to1.png]]

1. 届いたパケットの宛先MACアドレス(00:11:11:11:11:11)を見て,このMACア
   ドレスを持つホストがつながるポート番号をFDBから探す
2. FDBには「MACアドレス00:11:11:11:11:11=ポート1」と学習しているので,
   ポート1にパケットを出力する

ここまでの仕組みがわかれば,スイッチの機能を実現するコントローラ(ラーニ
ングスイッチ)をOpenFlowで実現するのは簡単です.

*** OpenFlow版スイッチ(ラーニングスイッチ)の仕組み
OpenFlowによるスイッチの構成は [[fig:switch_network_openflow]] のようになり
ます.一般的なハードウェアスイッチとの違いは次の2つです.

- FDBをソフトウェアとして実装し,コントローラが管理する
- パケットの転送は,コントローラがフローテーブルにフローエントリを書き
  込むことで制御する

なお,初期状態でのFDBとフローテーブルの中身はどちらも空です.

#+CAPTION: OpenFlow によるスイッチ (ラーニングスイッチ) の構成
#+NAME: fig:switch_network_openflow
[[./images/switch_network_openflow.png]]

この状態でホスト1がホスト2へパケットを送信すると,コントローラは次のよ
うにホスト1のネットワーク上での位置情報を学習します
([[fig:host1to2_openflow]]).

1. フローテーブルは空なのでパケットはPacket Inとしてコントローラまで上
   がる
2. コントローラはPacket Inメッセージからパケットの送信元MACアドレスとパ
   ケットの入ってきたポートの番号を調べ,「ポート1番にはMACアドレスが
   00:11:11:11:11:11のホストがつながっている」とFDBに保存する

#+CAPTION: Packet Inの送信元MACアドレスとスイッチのポート番号をFDBに学習する
#+NAME: fig:host1to2_openflow
[[./images/host1to2_openflow.png]]

*** Packet Outでパケットを転送(フラッディング)
学習が終わると次はパケットの転送です.もちろん,パケットの宛先はまだ学
習していないので,コントローラは次のようにパケットをばらまくことで宛先
まで届けます.このばらまく処理をフラッディングと呼びます
([[fig:host1to2_flood_openflow]]).

1. コントローラはPacket Inメッセージの宛先MACアドレスを調べ,FDBから送
   出先のポート番号を探す.しかし,ホスト2のMACアドレスとポート番号はま
   だFDBに入っていないのでわからない
2. コントローラはPacket Outメッセージ(出力ポート=フラッディング)でパケッ
   トをばらまくようにスイッチに指示する.その結果,ポート4につながるホ
   スト2にパケットが届く

#+CAPTION: パケットの宛先MACアドレスからスイッチのポート番号がFDBにみつからないため,Packet Outメッセージ(出力ポート=フラッディング)でパケットをばらまく
#+NAME: fig:host1to2_flood_openflow
[[./images/host1to2_flood_openflow.png]]

*** ふたたび学習と転送(Flow ModとPacket Out)

この状態でホスト2がホスト1へパケットを送信すると次のようになります
([[fig:host2to1_openflow]]).

1. フローテーブルが空なためコントローラまでふたたびPacket Inメッセージが上がる
2. コントローラはこのPacket Inメッセージから「ポート4番にはMACアドレス
   が00:22:22:22:22:22のホストがつながっている」とFDBに保存する
3. Packet Inの宛先MACアドレスとFDBを照らし合わせ,出力先のポート番号を
   探す.ここですでに「ポート1=MACアドレス00:11:11:11:11:11」と学習して
   いるので,出力ポートは1と決定できる
4. 「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエ
   ントリをFlow Modメッセージでフローテーブルに書き込む.加えて,
   Packet Outメッセージ(出力ポート=1)でPacket Inを起こしたパケットをポー
   ト1へ出力する

#+CAPTION: 同様にホスト2のMACアドレスとポート番号をFDBに学習し,フローエントリを書き込むとともにパケットをホスト1に届ける
#+NAME: fig:host2to1_openflow
[[./images/host2to1_openflow.png]]

さて,ここまでの段階でフローテーブルには「ホスト2からホスト1へのパケッ
トはポート1へ出力せよ」というフローエントリが入りました.もし,ホスト2
がホスト1へふたたびパケットを送信すると,今度はPacket Inがコントローラ
まで上がることはなく,スイッチ側だけでパケットを転送します.

残りのホスト1からホスト2へのフローエントリはどうでしょう.すでにFDBはす
べてのホストのMACアドレスとポート番号を学習してあります.もし,ふたたび
ホスト1からホスト2ヘパケットを送信すると,[[fig:host2to1_openflow]] と同様
にコントローラが「ホスト1からホスト2へのパケットはポート4へ出力せよ」と
いうフローエントリを書き込みます.もちろん,それ以降の通信ではPacket
Inはまったく上がらずにすべてスイッチ側だけでパケットを処理します.

ちょっと長くなってしまいましたがOpenFlowによるスイッチの実現方法がわか
りました.いよいよTremaでの実装に移ります.

*** LearningSwitchコントローラ

まずはラーニングスイッチのソースコード ([[list:learning_switch]]) をざっと
眺めてみましょう.とくに =private= の行よりも上のパブリックなメソッドに
注目してください.

#+NAME: list:learning_switch
#+BEGIN_SRC ruby
class LearningSwitch < Controller
  def start
    @fdb = {}
  end

  def packet_in( datapath_id, message )
    @fdb[ message.macsa ] = message.in_port
    port_no = @fdb[ message.macda ]
    if port_no
      flow_mod datapath_id, message, port_no
      packet_out datapath_id, message, port_no
    else
      flood datapath_id, message
    end
  end

  private

  def flow_mod( datapath_id, message, port_no )
    send_flow_mod_add(
      datapath_id,
      :match => ExactMatch.from( message ),
      :actions => SendOutPort.new( port_no )
    )
  end

  def packet_out( datapath_id, message, port_no )
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => SendOutPort.new( port_no )
    )
  end

  def flood( datapath_id, message )
    packet_out datapath_id, message, OFPP_FLOOD
  end
end
#+END_SRC

今までの知識だけでもこれだけたくさんのことがわかります.

- ラーニングスイッチの本体は =LearningSwitch= という名前のクラス
- 起動時に呼ばれる =start= ハンドラでFDBのインスタンス変数を作っている.
  ={}= という文法は見慣れないが,これにMACアドレスとポート番号の組を保
  存するらしい
- 見慣れない =packet_in= メソッドはPacket Inを捕捉するためのハンドラ.
  スイッチのフローエントリにマッチしないパケットがコントローラに上がっ
  てくると,このハンドラが呼ばれる
- Packet In ハンドラの中では,パケットの宛先MACアドレスからFDBでポート
  番号を調べている.もし宛先のポート番号がみつかった場合には,Flow Mod
  でフローエントリを打ち込みPacket Outでパケットを送信している.もしポー
  ト番号がみつからなかった場合は =flood= というメソッドを呼んでいる.こ
  れは先述した「パケットをばらまく(フラッディング)」の処理

いかがでしょうか.ラーニングスイッチの心臓部は Packet In ハンドラだけで,
その中身もやっていることはなんとなくわかると思います.細かい実装の解説
は後回しにして,さっそく実行してみましょう.

*** 実行してみよう

今回も仮想ネットワークを使って,仮想スイッチ1台,仮想ホスト2台の構成で
ラーニングスイッチを起動してみます.次の内容の設定ファイルを
=learning-switch.conf= として保存してください.

#+BEGIN_SRC ruby
vswitch("lsw") {
  datapath_id "0xabc"
}

vhost ("host1") {
  ip "192.168.0.1"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:01"
}

vhost ("host2") {
  ip "192.168.0.2"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:02"
}

link "lsw", "host1"
link "lsw", "host2"
#+END_SRC

=vhost= は仮想ホストの設定です.この設定ファイルでは =host1=, =host2=
という名前の2つの仮想ホストを起動します.また, =link= は仮想リンクで,
指定した仮想スイッチと仮想ホストを接続できます.ここでは,仮想スイッチ
=lsw= と,仮想ホスト =host1=, =host2= をそれぞれ仮想リンクで接続してい
ます.

次のように =trema run= の =-c= オプションにこの設定ファイルを渡してラー
ニングスイッチを実行します.ラーニングスイッチ自体の出力はありません.

#+BEGIN_SRC
prompt> trema run ./learning-switch.rb -c ./learning-switch.conf
#+END_SRC

別ターミナルを開き, =trema send_packets= コマンドを使ってhost1とhost2の
間でテストパケットを送ってみます.

#+BEGIN_SRC
prompt> trema send_packets --source host1 --dest host2
prompt> trema send_packets --source host2 --dest host1
#+END_SRC

=trema show_stats= コマンドでhost1 と host2の受信パケット数をチェックし,
それぞれでパケットを受信していれば成功です.

#+BEGIN_SRC
prompt> trema show_stats host1 --rx
ip_dst,tp_dst,ip_src,tp_src,n_pkts,n_octets
192.168.0.1,1,192.168.0.2,1,1,50
prompt> trema show_stats host2 --rx
ip_dst,tp_dst,ip_src,tp_src,n_pkts,n_octets
192.168.0.2,1,192.168.0.1,1,1,50
#+END_SRC

*** LearningSwitchのソースコード

それではラーニングスイッチのソースコードを読み解いていきましょう.今回
の肝となるのは,Packet Inハンドラでの次の処理です.

- FDBの更新とポート番号の検索
- ポート番号がみつかった場合の,Flow ModとPacket Out処理
- ポート番号がみつからなかった場合のフラッディング処理

それでは,最初にPacket Inハンドラの定義方法から見ていきましょう.

**** 未知のパケット(Packet In)の処理

コントローラに上がってくる未知のパケットを拾うには,Packet Inハンドラを
コントローラクラスに実装します.典型的なPacket Inハンドラは次のようにな
ります ([[list:learning_switch]]より抜粋).

#+BEGIN_SRC ruby
class LearningSwitch < Controller
  # ...

  def packet_in( datapath_id, message )
    # ...
  end

  # ...
#+END_SRC

最初の引数 =datapath_id= は,Packet Inを上げたスイッチのDatapath IDです.
二番目の引数 =message= は =PacketIn= クラスのインスタンスで,Packet In
メッセージをオブジェクトとしてラップしたものです.この =PacketIn= クラ
スには主に次の3種類のメソッドが定義されています.

- Packet Inを起こしたパケットのデータやその長さ,およびパケットが入って
  きたスイッチのポート番号などOpenFlowメッセージ固有の情報を返すメソッ
  ド
- Packet Inを起こしたパケットの種別(TCPかUDPか？またVLAN タグの有無な
  ど)を判定するための =?= で終わるメソッド
- 送信元や宛先のMACアドレス,IPアドレスなど,パケットの各フィールドを調
  べるためのアクセサメソッド

=PacketIn= クラスは非常に多くのメソッドを持っており,またTremaのバージョ
ンアップごとにその数も増え続けているためすべては紹介しきれません.付録
に代表的でよく使うものを紹介します.

**** FDBの更新とポート番号の検索
知らないパケットがPacket Inとして入ってきたとき,ラーニングスイッチは次
のようにFDBにホストの位置情報を学習し,宛先のポート番号を調べます.

1. パケットの送信元MACアドレスとパケットが入ってきたポート番号をPacket
   Inメッセージから取り出し,FDB(=@fdb=)に保存する
2. パケットの宛先MACアドレスとFDBから,パケットを出力するポート番号を調べる

FDBの実装は単純にハッシュテーブルを使っているだけなので,ひっかかる箇所
は無いと思います.

#+BEGIN_SRC ruby
class LearningSwitch < Controller
  # ...

  def packet_in( datapath_id, message )
    @fdb[ message.macsa ] = message.in_port
    port_no = @fdb[ message.macda ]

    # ...
  end

  # ...
end
#+END_SRC

**** 宛先ポート番号がみつかった場合(Flow ModとPacket Out)
もし宛先ポートがみつかった場合,以降は同じパケットは同様に転送せよ,と
いうフローエントリをスイッチに書き込みます(=flow_mod= メソッド).また,
Packet Inを起こしたパケットも忘れずにそのポートへ出力します
(=packet_out= メソッド).

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...
  port_no = @fdb[ message.macda ]
  if port_no
    flow_mod datapath_id, message, port_no
    packet_out datapath_id, message, port_no
  else

  # ...
#+END_SRC

この =flow_mod= メソッドと =packet_out= メソッドはそれぞれ=Controller=
クラスの =send_flow_mod_add= および =send_packet_out= (Packet Outの送
信)メソッドを次のように呼び出します.

#+BEGIN_SRC ruby
  # ...

  private

  def flow_mod( datapath_id, message, port_no )
    send_flow_mod_add(
      datapath_id,
      :match => ExactMatch.from( message ),
      :actions => SendOutPort.new( port_no )
    )
  end

  def packet_out( datapath_id, message, port_no )
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => SendOutPort.new( port_no )
    )
  end
  # ...
#+END_SRC

ここでいくつか見慣れない要素が登場しています.

- =send_flow_mod_add= の中では,マッチングルールに=ExactMatch.from= の
  返り値を指定している
- Packet Outの送信用メソッド (=send_packet_out=)

それでは,それぞれの詳細を見て行きましょう.

**** Exact Matchの作り方
マッチングルールの中でもすべての条件を指定したものをExact Matchと呼びま
す.たとえばPacket Inとしてコントローラに入ってきたパケットと,

- パケットが入ってきたスイッチのポート番号
- 送信元 MAC アドレス
- 宛先 MAC アドレス
- ...

などなどマッチングルールが定義する12個の条件がすべてまったく同じ,とい
うのがExact Matchです.

もし,Exact Matchを普通に作るとどうなるでしょうか？

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_flow_mod_add(
    datapath_id,
    :match => Match.new(
      :in_port => message.in_port
      :dl_src => message.macsa,
      :dl_dst => message.macda,
      # ...
#+END_SRC

うーん.やりたいことは分かりますが,マッチングルールを1つ作るだけでこの
ようにいちいち10行以上も書いていたらしんどいですよね.

そこで,TremaではこのようなExact Matchを楽に書ける次のショートカットを
用意しています.

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_flow_mod_add(
    datapath_id,
    :match => ExactMatch.from( message ),
    # ...
#+END_SRC

なんとたった1行で書けました! Tremaではこのようにプログラムを短く書ける
工夫がたくさんあります.これはそのつど紹介していくことにしましょう.

ところで今回のラーニングスイッチの例では,スイッチに書き込まれるフロー
エントリは次の2パターンだけです.

1. ホスト1からホスト2
2. ホスト2からホスト1

今回は流れるパケットの種類も限られていますので,フローエントリのマッチ
ングルールを楽に作るためにExact Macthを使っています.

**** Packet Out API
Packet OutはOpenFlowで定義されたメッセージの1つで,スイッチの指定したポー
トからパケットを送信させるためのものです.TremaでPacket Outを送るための
メソッド, =send_packet_out= は次の2つの引数を取ります.

#+BEGIN_SRC ruby
send_packet_out(datapath_id, options)
#+END_SRC

それぞれの引数の意味は次のとおりです.

- =datapath_id=: Packet Outの届け先となるスイッチのDatapath ID
- =options=: Packet Outメッセージの中身を決めるためのオプションで,アク
  ションによるパケットの書き換えや出力するポートを指定する.これはハッ
  シュテーブルで定義されていて,必要なオプションのみを指定すればいいこ
  とになっている

Packet Outの使い道は,Packet Inメッセージとして入ってきたパケットをその
ままスイッチのポートから送り出す場合がほとんどです.この場合,パケット
の送信にスイッチのバッファを使う場合と使わない場合とで呼び出しかたが変
わります.

***** スイッチのバッファを使ってPacket Outする場合
パケットのデータがスイッチのバッファに乗っていることが期待できる場合に
は,次のように =:buffer_id= オプションでバッファに乗っているパケットデー
タのIDを指定してやることでPacket Outできます.

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_packet_out(
    datapath_id,
    :buffer_id => message.buffer_id,
    :data => message.data,
    :actions => SendOutPort.new( port_number )
  )
#+END_SRC

この場合コントローラからスイッチへのパケットデータのコピーが起こらない
ため,若干のスピードアップが期待できます.ただし,バッファの中身は予測
不能でいつデータが消えるかわからないため,この方法は推奨しません.

***** スイッチのバッファを使わずに Packet Out する場合
スイッチのバッファを使わずにPacket Outする場合,次のように =:data=オプ
ションでパケットのデータを指定する必要があります.バッファに乗っている
かいないかにかかわらずPacket Outできるので,若干遅くなりますが安全です.

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_packet_out(
    datapath_id,
    :data => message.data,
    :actions => SendOutPort.new( port_number )
  )
#+END_SRC

これは,次のように =:packet_in= オプションを使うことで若干短くできます
(=.data= を書かなくてよくなります).

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_packet_out(
    datapath_id,
    :packet_in => message,
    :actions => SendOutPort.new( port_number )
  )
#+END_SRC

=options= に指定できる主なオプションは付録を参照してください.

**** 宛先ポート番号がみつからなかった場合(フラッディング)
もし宛先ポートがみつからなかった場合,コントローラはPacket Inしたメッセー
ジをフラッディングしてばらまきます.これをやっているのが =flood= メソッ
ドで,実体は =packet_out= メソッドのポート番号に仮想ポート番号
=OFPP_FLOOD= を指定しているだけです.これが指定されたPacket Outメッセー
ジをスイッチが受け取ると,指定されたパケットをフラッディングします.

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...
  port_no = @fdb[ message.macda ]
  if port_no
    # ...
  else
    flood datapath_id, message
  end
  # ...
end

private

# ...

def flood( datapath_id, message )
  packet_out datapath_id, message, OFPP_FLOOD
end
#+END_SRC

*** まとめ
さまざまなOpenFlowアプリケーションのベースとなるラーニングスイッチの動
作と作り方を学びました.

- コントローラは,Packet Inメッセージから送信元ホストのMACアドレスとホ
  ストのつながるスイッチポート番号をFDBに学習する
- Packet Inの転送先がFDBから分かる場合,Flow Modで以降の転送情報をスイッ
  チに書き込みPacket Outする.FDBで決定できない場合は,入力ポート以外の
  すべてのポートにPacket Outでフラッディングする.

続いてはこのラーニングスイッチを少し改造してトラフィック集計機能を加え
ます.

** 「トラフィック集計スイッチ」 コントローラの概要
トラフィック集計スイッチは,パっと見は普通の L2 スイッチとして動作しま
す.しかし,裏では各ホストが送信したトラフィックをカウントしており,定
期的に集計情報を表示してくれます.これを使えば,ネットワークを無駄に使
いすぎているホストを簡単に特定できます.

*** 設計と実装
「L2 スイッチ機能」と「トラフィックの集計機能」のためにはどんな部品が必
要でしょうか？ まずは,スイッチに指示を出す上司にあたるコントローラクラ
スが必要です.これを `TrafficMonitor` クラスと名付けましょう.また,パ
ケットを宛先のスイッチポートへ届けるための `FDB` クラス (注1),あとはト
ラフィックを集計するための `Counter` クラスの 3 つが最低限必要です.

注1) FDB とは Forwarding DataBase の略で,スイッチの一般的な機能です.
詳しくは続く実装で説明します.

**** FDBクラス
`FDB` クラス (リスト1) は,ホストの MAC アドレスとホストが接続している
スイッチポートの対応を学習するデータベースです.このデータベースを参照
することで,`packet_in` メッセージで入ってきたパケットの宛先 MAC アドレ
スからパケット送信先のスイッチポートを決定できます.

#+BEGIN_SRC ruby
class FDB
  def initialize
    @db = {} # <- 連想配列(MACアドレス→スイッチポート番号)
  end

  def lookup mac # <- MACアドレスからスイッチポート番号を引く
    @db[ mac ]
  end

  def learn mac, port_number # <- MACアドレス＋スイッチポートを学習
    @db[ mac ] = port_number
  end
end
#+END_SRC

リスト1　MACアドレス→スイッチポートのデータベースFDBクラス(fdb.rb)

**** Counter クラス
`Counter` クラス (リスト2) は,ホスト （MAC アドレスで区別します） ごと
の送信パケット数およびバイト数をカウントします.また,カウントした集計
情報を表示するためのヘルパメソッドを提供します.

#+BEGIN_SRC ruby
class Counter
  def initialize
    @db = {} # <- ホストごとの集計情報を記録する連想配列
  end

  def add mac, packet_count, byte_count # <- ホスト (MAC アドレス = mac) の送信パケット数,バイト数を追加
    @db[ mac ] ||= { :packet_count => 0, :byte_count => 0 }
    @db[ mac ][ :packet_count ] += packet_count
    @db[ mac ][ :byte_count ] += byte_count
  end

  def each_pair &block # <- 集計情報の表示用
    @db.each_pair &block
  end
end
#+END_SRC

リスト2　トラフィックを記録し集計する `Counter` クラス (`counter.rb`)

**** TrafficMonitor クラス
`TrafficMonitor` クラスはコントローラの本体です (リスト3).メインの処理
はリスト 3 1-3 の 3 つになります.

1. `packet_in` メッセージが到着したとき,パケットを宛先のスイッチポートに転送し,フローテーブルを更新する部分
2. `flow_removed` メッセージが到着したとき,トラフィック集計情報を更新する部分
3. タイマーで 10 秒ごとにトラフィックの集計情報を表示する部分

#+BEGIN_SRC ruby
require "counter"
require "fdb"

class TrafficMonitor < Controller
  periodic_timer_event :show_counter, 10 # (3)

  def start
    @counter = Counter.new # <- Counter オブジェクト
    @fdb = FDB.new # <- FDB オブジェクト
  end

  def packet_in datapath_id, message # (1)
    macsa = message.macsa # <- パケットを送信したホストの MAC アドレス
    macda = message.macda # <- パケットの宛先ホストの MAC アドレス

    @fdb.learn macsa, message.in_port
    @counter.add macsa, 1, message.total_len
    out_port = @fdb.lookup( macda )
    if out_port
      packet_out datapath_id, message, out_port
      flow_mod datapath_id, macsa, macda, out_port
    else
      flood datapath_id, message
    end
  end

  def flow_removed datapath_id, message # (2)
    @counter.add message.match.dl_src,message.packet_count, message.byte_count
  end

  private # <- 以下,プライベートメソッド

  def show_counter # <- カウンタを表示
    puts Time.now
    @counter.each_pair do | mac, counter |
      puts "#{ mac } #{ counter[ :packet_count ] } packets (#{ counter[ :byte_count ] } bytes)"
    end
  end

  def flow_mod datapath_id, macsa, macda, out_port # <- macsa から macda へのパケットを out_port へ転送する flow_mod を打つ
    send_flow_mod_add(
      datapath_id,
      :hard_timeout => 10, # <- flow_mod の有効期限は10秒
      :match => Match.new( :dl_src => macsa, :dl_dst => macda ),
      :actions => Trema::ActionOutput.new( out_port )
    )
  end

  def packet_out datapath_id, message, out_port # <- packet_in したメッセージを out_port へ転送
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => Trema::ActionOutput.new( out_port )
    )
  end

  def flood datapath_id, message # <- packet_inしたメッセージをin_port以外の全スイッチポートへ転送
    packet_out datapath_id, message, OFPP_FLOOD
  end
end
#+END_SRC

リスト3　本体 `TrafficMonitor` クラス (`traffic-monitor.rb`)

それでは,とくに重要な (1) の処理を詳しく見ていきましょう.なお,リスト
3 中で使われているメソッドの引数など API の詳細については,「Trema
Ruby API ドキュメント」 を参照してください.

以下の説明では図 3 に示すホスト 2 台 + スイッチ 1 台からなるネットワー
ク構成を使います.host1 から host2 にパケットを送信したときの動作シーケ
ンスは図 4 のようになります.

#+CAPTION: TrafficMonitor を動作させるネットワーク構成の例
[[https://github.com/trema/Programming-Trema/raw/master/images/2_003.png]]
図3　`TrafficMonitor` を動作させるネットワーク構成の例

#+CAPTION: host1からhost2宛にパケットを送信したときの動作シーケンス
[[https://github.com/trema/Programming-Trema/raw/master/images/2_004.png]]
図4　`host1` から `host2` 宛にパケットを送信したときの動作シーケンス

1. `host1` から `host2` を宛先としてパケットを送信すると,まずはスイッ
   チにパケットが届く
2. スイッチのフローテーブルは最初はまっさらで,どう処理すればよいかわか
   らない状態なので,コントローラである `TrafficMonitor` に
   `packet_in` メッセージを送る
3. `TrafficMonitor` の `packet_in` メッセージハンドラでは,`packet_in`
   メッセージの `in_port` (`host1` のつながるスイッチポート) と
   `host1` の MAC アドレスを FDB に記録する
4. また,`Counter` に記録された `host1` の送信トラフィックを 1 パケット
   分増やす
5. `packet_in` メッセージの宛先 MAC アドレスから転送先のスイッチポート
   番号を FDB に問い合わせる.この時点では `host2` のスイッチポートは学
   習していないので,結果は 「不明」
6. そこで,パケットを `in_port` 以外のすべてのスイッチポートに出力する
   `packet_out` メッセージ (FLOOD と呼ばれる) をスイッチに送り,
   `host2` が受信してくれることを期待する
7. スイッチは,パケットを `in_port` 以外のすべてのポートに出す

これで,最終的に `host2` がパケットを受信できます.逆に,この状態で
`host1` を宛先として `host2` からパケットを送信したときの動作シーケンス
は次のとおりになります (図5).4 までの動作は図 4 と同じですが,5 からの
動作が次のように異なります.

#+CAPTION: host1 から host2 宛にパケットを送信したときの動作シーケンス
[[https://github.com/trema/Programming-Trema/raw/master/images/2_005.png]]
図5　host1 から host2 宛にパケットを送信したときの動作シーケンス

1. `host1` から `host2` を宛先としてパケットを送信すると,まずはスイッ
   チにパケットが届く
2. スイッチのフローテーブルは最初はまっさらで,どう処理すればよいかわか
   らない状態なので,コントローラである `TrafficMonitor` に
   `packet_in` メッセージを送る
3. `TrafficMonitor` の `packet_in` メッセージハンドラでは,`packet_in`
   メッセージの `in_port` (`host1` のつながるスイッチポート) と
   `host1` の MAC アドレスを FDB に記録する
4. また,`Counter` に記録された `host1` の送信トラフィックを 1 パケット
   分増やす
5. `packet_in` メッセージの宛先 MAC アドレスから,転送先のスイッチポー
   ト番号を FDB に問い合わせる.これは,先ほど `host1` から `host2` に
   パケットを送った時点で FDB に学習させているので,送信先はスイッチポー
   ト 1 番ということがわかる
6. そこで,`TrafficMonitor` はパケットをスイッチポート 1 番へ出力する
   `packet_out` メッセージをスイッチに送る.スイッチはこれを受け取ると,
   パケットをスイッチポート 1 番に出し,最終的に `host1` がパケットを受
   信する
7. 「送信元 = 00:00:00:00:00:02,送信先 = 00:00:00:00:00:01 となるパケッ
   トはスイッチポート 1 番に転送せよ」 という `flow_mod` メッセージをス
   イッチに送信する

最後の 7 によって,以降の `host2` から `host1` へのパケットはすべてスイッ
チ側だけで処理されるようになります.

** 実行してみよう

それでは,早速実行してみましょう (注2).リスト 4 の内容の仮想ネットワー
ク設定を `traffic-monitor.conf` として保存し,次のように実行してくださ
い.

#+BEGIN_SRC
prompt> ./trema run ./traffic-monitor.rb -c ./traffic-monitor.conf
#+END_SRC
リスト 4　仮想スイッチ `0xabc` に仮想ホスト `host1`,`host2` を接続する設定

#+BEGIN_SRC ruby
vswitch { # <- 仮想スイッチ 0xabc を定義
  datapath_id 0xabc
}

vhost ("host1") { # <- 仮想ホスト host1 を定義
  ip "192.168.0.1"
  mac "00:00:00:00:00:01"
}

vhost ("host2") { # <- 仮想ホスト host2 を定義
  ip "192.168.0.2"
  mac "00:00:00:00:00:02"
}

link "0xabc", "host1" # <- ホスト host1,host2 をスイッチ 0xabc に接続
link "0xabc", "host2"
#+END_SRC

実行すると,図 3 に示した仮想ネットワークが構成され,`TrafficMonitor`
コントローラが起動します.

それでは,実際にトラフィックを発生させて集計されるか見てみましょう.
Trema の `send_packets` コマンドを使うと,仮想ホスト間で簡単にパケット
を送受信できます.別ターミナルを開き,次のコマンドを入力してください.

#+BEGIN_SRC
prompt> ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10← host1からhost2宛にパケットを10個送る
prompt> ./trema send_packets --source host2 --dest host1 --n_pkts 10 --pps 10← host2からhost1宛にパケットを10個送る
#+END_SRC

`trema run` を実行した元のターミナルに次のような出力が出ていれば成功です(注3).

#+BEGIN_SRC
    ...
    00:00:00:00:00:01 10 packets (640 bytes)
    ↑host1からパケットが10個送信された

    00:00:00:00:00:02 10 packets (640 bytes)
    ↑host2からパケットが10個送信された
    ...
#+END_SRC

注2) Trema のセットアップが済んでいない人は,前回もしくは Trema のドキュ
メントを参考にセットアップしておいてください.なお,Trema は頻繁に更新
されていますので,すでにインストールしている人も最新版にアップデートす
ることをお勧めします.

注3) その他のトラフィック情報も出るかもしれませんが,これは Linux カー
ネルが送っている IPv6 のパケットなので,`host1`, `host2` とは関係あり
ません.

** まとめ
今回は 「トラフィック集計機能付きスイッチ」 を実現するコントローラを書
きました.学んだことは次の2つです.

- 電話サポートの例を使って OpenFlow の動作モデルを学びました.パケット
  の転送はスイッチ上のフローテーブルによって行われ,`flow_mod` メッセー
  ジによって書き換えることができます.また,フローテーブルに登録されて
  いないパケットによって `packet_in` メッセージがコントローラに届きます.
- 仮想ネットワークを使ったコントローラの動作テスト方法を学びました.仮
  想スイッチと仮想ホストを起動してつなぎ,`send_packets` コマンドを使っ
  て仮想ホスト間でパケットを送受信することで,コントローラの簡単な動作
  テストができます.

次回は Trema を使ったテストファースト開発を紹介します.Rails や
Sinatra を使った Web アジャイル開発ではお馴染みのテストファースト開発で
すが,もちろん Trema でもサポートしています.とくに OpenFlow コントロー
ラのように複雑な動作シーケンスを持つソフトウェアの実装には,テストファー
ストによるインクリメンタルな開発が有効です.

* 実践! 生活ネットワークを OpenFlow に移行しよう
そろそろ独り立ちするときがやってきました.これまで本連載では,OpenFlow
コントローラの書き方と Trema の仮想ネットワークを使った実行方法を学び
ました.OpenFlow プログラマとしてやっていくための基本的な知識はすべて
身に付きました.

次はなにをすればよいでしょうか？あとはやってみるだけです.まずは自宅の
ネットワークを OpenFlow で置き換えましょう.うまくいったら,こんどは職
場のネットワークを OpenFlow で置き換えましょう.その環境で実際に暮らし
てみて,初めて見えてくるアイデアや改善案があります.これは,とにかくやっ
てみなければ絶対にわからないことです.

「怒られるかもしれない」.あなたはそう考えます.家のネットワークはとも
かく,職場のネットワークを止めてしまったらどうしよう….管理者や上司に
注意されたらどうしよう….大丈夫です.筆者たちも何度も怒られたことがあ
りますが,その経験からうまくやる方法を学びました.

今回は我々の経験を踏まえ,既存のネットワークを "穏便" に OpenFlow へ移
行するためのテクニックを教えます.ちょっとした OpenFlow プログラムを書
くだけで,移行の際に起こりがちなネットワーク障害を簡単に防げます.まず
は,筆者たちの失敗談を振り返らせてください.

** 失敗談
話は 2009 年 7 月までさかのぼります.OpenFlow が登場したばかりの当時,
筆者たちはさっそく OpenFlow コントローラを書いて小さなネットワークを職
場に構築しました.うまく動作して気を良くした我々は,職場のネットワーク
とこの OpenFlow ネットワークをいきなりつないでみました.まあ大丈夫だろ
うと楽観的に考えていたのです.結果的にはすぐにネットワーク障害が起こり,
事態に気づいた管理者からお叱りのメールを受け取ることになりました.

当時の状況を単純化すると図 1 のようになります.

#+CAPTION: 障害を起こしたときのネットワーク構成を簡略化したもの
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/001.png]]

職場ネットワーク (レガシーネットワークとします) のスイッチにはホストが
つながれており,そのうちのスイッチポート 3 番を OpenFlow スイッチポート
の 1 番と接続しました.この OpenFlow スイッチは,我々が書いた
BuggyController という OpenFlowコントローラで制御されています.

*** 「警告が出ているんですけど」
具体的な障害の症状はこうでした.レガシーネットワークと OpenFlow ネット
ワークを接続してすぐに,レガシースイッチにつながったホストどうしが通信
できなくなりました.そして,ネットワークを監視する watchdog プログラム
が「Host Flapping が起こっている」という警告を出しました.これは,1 つ
のホストがいくつかのポートの間で高速に移動しているように見えるというも
のです.我々はすぐに OpenFlow ネットワークを切断し,原因の分析にとりか
かりました.

*** 障害の原因
分析の結果,次のようなシナリオで起こっているのではないかという結論に至
りました.

1. host1 が host2 へパケットを送信する
2. BuggyController は OpenFlow スイッチポート 1 番からの packet_in を
   受け取り,OpenFlow スイッチのスイッチポート 1 番に host1 がつながっ
   ていると学習する
3. host2 が host1 へパケットを送信する
4. BuggyController はスイットポート 1 番から「宛先=host1」の packet_in
   を受け取る.ここで,host1 は OpenFlow スイッチのスイッチポート 1 番
   にあると学習しているので,スイッチポート 1 番に packet_out する
5. 結果的に,host1 はポート 2 と 3 の両方から同じパケットを受け取る.
   外から見ると,host2 がスイッチポート 2 番と 3 番を高速に移動してい
   るように見える.

つまり,BuggyController が予期せぬパケットをレガシーネットワークに送っ
たおかげでネットワークが混乱し,通信できない状況が起きたのです.

*** 教訓: これをやってはいけない
振り返ると,失敗した原因は 2 つありました.

1 つは,OpenFlow ネットワークをいきなりレガシーネットワークとつないで
しまったことです.OpenFlow ネットワーク単体では動いていたという言い訳
はありますが,いきなりつないでしまったのは若気の至り & 経験不足でした.

もう 1 つは,BuggyController が packet_in したスイッチポートに
packet_out していたことです.assert を入れるなど防御的プログラミングが
徹底できていれば防げるバグでしたが,残念ながら当時の我々では気づくこと
ができませんでした.レガシーネットワークにつないで初めて顕在化するバグ
と言えます.

** OpenFlow への移行パターン
大失敗をやらかしてしまった筆者たちは,作戦を練りなおさざるを得なくなり
ました.いろいろな方向から考えなおしたところ,OpenFlow への移行方法には
次の 3 つのパターンがあることがわかりました.もちろん,それぞれでメリッ
ト／デメリットや危険度が異なります.

*** 独立ネットワークパターン
最初のパターンは,既存のレガシーネットワークにまったく手を加えずに,独
立した形でOpenFlowネットワークを構築する方法です（図2）.それぞれのネッ
トワーク間でパケットの行き来はなく,お互いに完全に独立しています.

#+CAPTION: レガシーネットワークとは独立した OpenFlow ネットワークを構築し,徐々に拡大する
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/002.png]]

この状態から,レガシーネットワーク内のサーバや端末を徐々にOpenFlowネッ
トワークに移動することで移行していきます.

それぞれのネットワーク間ではパケットが行き来できないので,OpenFlowネッ
トワークがレガシーネットワークに悪影響を及ぼす可能性はほとんどありませ
ん.ただし,OpenFlowネットワークに移行する際には関連する機器どうし（ファ
イルサーバとクライアント群など）を一度に移行する必要があります.これは
トラブルを起こす可能性が高いため,移行が難しいという問題があります.

*** いきなり接続パターン
次のパターンは,我々がやったようにレガシーネットワークとOpenFlowネット
ワークをいきなりつなげてしまう方法です（図3）.

#+CAPTION: レガシーネットワークと OpenFlow ネットワークを直結してしまう
http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/003.png

相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできま
す.このため,独立ネットワークパターンに比べて移行の手間はずっと小さい
と言えます.

OpenFlowネットワークのコントローラが完璧に作られていれば,このようにい
きなりつなげても問題はありませんが,完璧なテストというのは難しいです.
ユニットテストによって関数レベルで細かくテストすることもできますが（注
4）,それだけでは不十分です.というのも,我々が失敗したように,生のトラ
フィックをコントローラに流し込んでみて初めて見つかるバグがあるからです.
よって,この方法は自宅ネットワークなど自由にいじれるネットワーク以外で
は推奨できません.

*** 逆流防止パターン
最後のパターンは,今までに挙げてきた2つのパターンのいいとこどりです.2
つのネットワークを接続するのですが,そのときに「逆流防止弁」を付けてパ
ケットの逆流が起きないようにします（図4）.

#+CAPTION: レガシーネットワークとOpenFlowネットワークの間での逆流を防止する
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/004.png]]

たとえば,「レガシーネットワーク→OpenFlowネットワーク」のような一方向
のパケットは通しますが,同じパケットがレガシー側に戻ることを防ぎます.
逆方向でも同じです.

この方法の利点は,逆流を防ぐだけでかなりの障害を未然に防げることです.
また,使い勝手はいきなり接続した場合と同じなのでOpenFlowへの移行も楽で
す.

検討の結果,このパターンが一番良さそうでした.この逆流防止弁はOpenFlow
コントローラとして実装できそうです.前置きが長くなりましたが,さっそく
Tremaを使って実装してみましょう.

** 逆流防止弁
逆流防止弁は1つのpacket_inに対して2つのフローを設定します.1つは順方向
のフローで,入ってきたパケットをもう1つのスイッチポートに転送します.も
う1つは逆方向のフローで,同じパケットが逆方向に流れてきたときにこのパケッ
トを落とします.

*** 実装
逆流防止弁（OneWayBridgeコントローラ）のソースコードをリスト1に示します.
このコントローラは,packet_inとflow_removedのハンドラを定義しています.

#+BEGIN_SRC ruby
  class OneWayBridge < Controller
    # 順方向と逆方向のフローを設定する
    def packet_in datapath_id, message
      out_port = { 1 => 2, 2 => 1 }[ message.in_port ]
      add_flow datapath_id, message.macsa, message.in_port, out_port
      send_packet datapath_id, message, out_port
      add_drop_flow datapath_id, message.macsa, out_port
    end

    # 順方向と逆方向のフローのいずれかが消えたときに,もう1つも消す
    def flow_removed datapath_id, message
      delete_flow datapath_id, message.match.dl_src
    end

    # 以下,プライベートメソッド
    private

    # 送信元MACアドレスがmacsaで,スイッチポートin_portからout_portへのフローを追加
    def add_flow datapath_id, macsa, in_port, out_port
      send_flow_mod_add(
        datapath_id,
        :idle_timeout => 10 * 60,
        :match => Match.new( :in_port => in_port, :dl_src => macsa ),
        :actions => ActionOutput.new( :port => out_port )
      )
    end

    # パケットをスイッチポートout_portへ転送
    def send_packet datapath_id, message, out_port
      send_packet_out(
        datapath_id,
        :packet_in => message,
        :actions => ActionOutput.new( :port => out_port )
      )
    end

    # 逆流してきたパケットを落とすフローを追加（:actionsを指定していないので,マッチしたパケットを落とす）
    def add_drop_flow datapath_id, macsa, in_port
      send_flow_mod_add(
        datapath_id,
        :idle_timeout => 10 * 60,
        :match => Match.new( :in_port => in_port, :dl_src => macsa )
      )
    end

    # 順方向と逆方向のフローを両方とも消す
    def delete_flow datapath_id, macsa
      send_flow_mod_delete(
        datapath_id,
        :match => Match.new( :dl_src => macsa )
      )
    end
  end
#+END_SRC

Packet In ハンドラ (=packet_in= メソッド) では,Packet In したスイッチ
ポートとは別のポートへパケットを転送するフロー (たとえば,スイッチポー
ト 1 番から入ってきたパケットはスイッチポート 2 番に転送するフロー) を
設定し (=add_flow= メソッド),実際にパケットを転送します
(=send_packet= メソッド).また,同じパケットが逆向きに流れないようにす
るフローを設定することで逆流を防ぎます (=add_drop_flow= メソッド).

Flow Removed ハンドラ (=flow_removed= メソッド) は,順方向または逆方向
のフローが消えたときに呼ばれます.これらのフローはどちらも =:dl_src= に
同じ MAC アドレスが指定されているので =delete_flow= メソッドでもう片方
を消します.なおここではやっていませんが,Flow Removed メッセージに乗っ
てくる統計情報[fn:1]を使って,逆流パケットがあった場合には警告メッセー
ジを出すようにするとさらに効果的でしょう.

[fn:1] 「トラフィック集計スイッチ」でこのテクニックを使いました.

*** 実行
それではさっそく実行してみましょう.実行のためには,レガシーネットワー
クとOpenFlowネットワークの間にOneWayBridgeコントローラで制御する仮想ス
イッチ（vswitch）をはさみます（図5）.vswitchのポートは,vswitchを実行
するマシンのNIC（eth0,eth1）に結び付けます.

#+CAPTION: 逆流防止弁（OneWayBridgeコントローラ）を実行するときの物理構成
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/005.png]]

図5の物理構成をTrema設定ファイルにしたものがリスト
2（one-way-bridge.conf）です.仮想リンク（link で始まる行）の端点にイン
ターフェース名eth0,eth1を指定していることに注目してください.

#+CAPTION: 逆流防止弁（OneWayBridgeコントローラ）の設定ファイル
#+BEGIN_SRC ruby
vswitch ( "bridge" ) {
  datapath_id 0xabc
}

link "bridge", "eth0"
link "bridge", "eth1"
#+END_SRC

実行するには,この設定ファイルをtrema runの-cオプションに渡します.

#+BEGIN_SRC
prompt> ./trema run ./one-way-bridge.rb -c ./one-way-bridge.conf
#+END_SRC

*** 使ってみた
さっそくこの逆流防止弁を導入したところ,期待していたとおり,問題は起こ
らなくなりました.現在,OpenFlowスイッチ5台,ホスト約100台から構成され
るOpenFlowネットワークを職場ネットワークと接続して運用しています.もち
ろん,このOpenFlowネットワークはどんどん拡大しつつあり,ゆくゆくは職場
ネットワークを置き換える予定です.

** まとめ

職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました.今
回学んだことは次の2つです.

- 既存のレガシーネットワークをOpenFlowに移行するいくつかのパターンを見
  ました.自宅ネットワークなど自由にできるネットワークでは「いきなり接
  続パターン」で十分ですが,職場ネットワークでは「逆流防止パターン」が
  最適です
- 逆流防止弁を実現するOpenFlowコントローラを実装しました.基本的には2つ
  のフローを設定するだけで,簡単に逆流を防止できます

* 付録
** PacketIn クラスの主なメソッド
: @<tt>{:data}
  パケットのデータ全体をバイナリ文字列で返す

: @<tt>{:in_port}
  パケットが入ってきたスイッチのポート番号を返す

: @<tt>{:total_len}
  パケットのデータ長を返す

: @<tt>{:buffered?}
  Packet Inを起こしたパケットがスイッチにバッファされているかどうかを返す

: @<tt>{:macsa}
  パケットの送信元MACアドレスを返す

: @<tt>{:macda}
  パケットの宛先MACアドレスを返す

: @<tt>{:ipv4?}
  パケットがIPv4である場合@<tt>{true}を返す

: @<tt>{:ipv4_saddr}
  パケットの送信元IPアドレスを返す

: @<tt>{:ipv4_daddr}
  パケットの宛先IPアドレスを返す

: @<tt>{:tcp?}
  パケットがTCPである場合@<tt>{true}を返す

: @<tt>{:tcp_src_port}
  パケットのTCPの送信元ポート番号を返す

: @<tt>{:tcp_dst_port}
  パケットのTCP宛先ポート番号を返す

: @<tt>{:udp?}
  パケットがUDPである場合@<tt>{true}を返す

: @<tt>{:udp_src_port}
  パケットのUDPの送信元ポート番号を返す

: @<tt>{:udp_dst_port}
  パケットのUDPの宛先ポート番号を返す

: @<tt>{:vtag?}
  パケットにVLANヘッダが付いている場合@<tt>{true}を返す

: @<tt>{:vlan_vid}
  VLANのVIDを返す

このようなメソッドは他にもたくさんあります.メソッドの完全なリストや詳
しい情報を知りたい場合には,@<chap>{openflow_framework_trema}で紹介した
@<tt>{trema ruby}コマンドで最新のTrema APIドキュメントを参照してくださ
い.
** send_packet_out の主なオプション
: @<tt>{:buffer_id}
  スイッチでバッファされているパケットのIDを指定する.この値を使うと,
  スイッチでバッファされているパケットを指定してPacket Outできるので効
  率が良くなる(ただし,スイッチにバッファされていない時はエラーになる)

: @<tt>{:data}
  Packet Outするパケットの中身を指定する.もし@<tt>{:buffer_id}オプショ
  ンが指定されておりスイッチにバッファされたパケットをPacket Outする場
  合,この値は使われない

: @<tt>{:packet_in}
  @<tt>{:data}および@<tt>{:in_port} オプションを指定するためのショート
  カット@<fn>{in_port_option}.@<tt>{packet_in}ハンドラの引数として渡さ
  れる@<tt>{PacketIn}メッセージを指定する

: @<tt>{:actions}
  Packet Outのときに実行したいアクションの配列を指定する.アクションが
  1つの場合は配列でなくてかまわない

footnote[in_port_option][@<tt>{:in_port}オプションは出力ポートに@<tt>{OFPP_TABLE}という特殊なポートを指定したときに使うオプションです.通常はまったく使いませんが,もし知りたい方はTrema Ruby APIを参照してください.]
