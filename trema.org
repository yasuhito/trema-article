* Trema と OpenFlow 入門
** はじめに
ネットワークをソフトウェアで制御する仕組みとして OpenFlow が注目を集め
ています. しかし最近, 一気にブームが加熱し手に入る情報も急激に増えたた
め, 「結局 OpenFlow とは何なのか？」が初心者には分かりづらくなっている
のも事実です.

OpenFlow を正しく一言で説明すると, 「ネットワークスイッチを制御するため
の標準プロトコルの一種」となります[fn:onf]. つまり OpenFlow に対応した
スイッチでネットワークを組めば, すべてのスイッチ, つまりネットワーク全
体をプロトコルを通じて制御できるようになります.

もちろん, OpenFlow プロトコルの実装には自由なプログラミング言語を使えま
す. たとえば HTML と Web サイトの関係を見てください. Web サイトを作るに
は, W3C が標準化する HTML を使って Web ページを作ります. プログラマが使
う言語に対応した Web フレームワーク (Rails や Django など) を使います.
OpenFlow もこれと同じで, HTML に当たる標準が OpenFlow であり, これを実
装したライブラリを使えばどんな言語でも OpenFlow スイッチをコントロール
できます.

これがいわゆる SDN (Software Defined Network), つまり「ネットワーク機器
をプログラミングする」というプログラミングの新ジャンルです.

OpenFlow では, このスイッチをコントロールするソフトウェアをコントローラ
と呼びます. 究極的には, ネットワーク内のすべてのスイッチを制御するコン
トローラを書けば, ネットワーク全体をソフトウェアとして記述できることに
なります ([[fig:openflow_controller]]).

#+CAPTION: OpenFlow スイッチとコントローラの関係
#+NAME: fig:openflow_controller
[[./images/openflow_controller.png]]

[fn:onf] OpenFlow の詳しい仕様書や標準化に関する情報は、Open Networking Foundation のサイト (https://www.opennetworking.org/) で入手できます。

OpenFlowの登場によって，今までは専門のオペレータによって管理されていた
ネットワークがついにプログラマ達にも開放されました。ネットワークをソフ
トウェアとして記述することにより，たとえば「アプリに合わせて勝手に最適
化するネットワーク」や「障害が起こっても自己修復するネットワーク」といっ
た究極の自動化も夢ではなくなります！

本連載では，このOpenFlowプロトコルを使ってネットワークを「ハック」する
方法を数回に渡って紹介します。職場や自宅のような中小規模ネットワークで
もすぐに試せる実用的なコードを通じて，「OpenFlowって具体的に何に使える
の？」というよくある疑問に答えていきます。OpenFlowやネットワークの基礎
から説明しますので，ネットワークの専門家はもちろん，普通のプログラマも
すんなり理解できると思います。

まずは，OpenFlowプログラミングのためのフレームワーク「Trema（トレマ）」
を紹介しましょう。
** OpenFlow プログラミングフレームワーク Trema
Tremaは，OpenFlowコントローラを開発するためのRubyおよびC用のプログラミ
ングフレームワークです。ノートPC1台でアジャイルにOpenFlow開発をしたいな
ら，「OpenFlow界のRails」ことTremaで決まりです。GitHub上で開発されてお
り，GPLv2ライセンスのフリーソフトウェアとして公開されています。公開は今
年の4月と非常に新しいソフトウェアですが，その使いやすさから国内外の大学
や企業および研究機関などですでに採用されています。

Tremaの情報は次のサイトから入手できます。

- Tremaホームページ
- GitHubのページ
- メーリングリスト
- Twitterアカウント：@trema_news

Tremaを使うと，ノートPC1台でOpenFlowコントローラの開発とテストができま
す。本連載では，実際にTremaを使っていろいろと実験しながらOpenFlowコント
ローラを作っていきます。それでは早速Tremaをセットアップして，簡単なプロ
グラムを書いてみましょう。
*** Trema のセットアップ
Trema は Linux 上で動作します。次のディストリビューションとバージョンで
の動作を保証しています。

 * Ubuntu 10.04 以降 (i386/amd64, デスクトップ版)
 * Debian GNU/Linux 6.0 (i386/amd64)

なお公式にサポートはしていませんが、RedHat などその他の代表的な Linux
ディストリビューションでも動作するはずです。本連載では、Ubuntu の最新バー
ジョンである 11.04 (デスクトップエディション 32 ビット版) を使います。

Trema の提供する trema コマンドの実行には root 権限が必要です。Trema は
内部的に、sudo コマンドを使って root 権限でいくつかのコマンドを実行しま
す。まずは、sudo コマンドを使って root 権限でコマンドを実行できるかどう
か、sudo の設定ファイルを確認してください。

sudo が正しく設定できていることを確認したら、Trema のインストールや実行
に必要ないくつかのソフトウェアをインストールしましょう。

 * Ruby インタプリタ。Trema は Ruby と C で作成されていて、アプリケーショ
   ンの記述にも Ruby を使います。Trema では Ruby のバージョン 1.8.7 が
   必要です。1.8.6 以前のバージョンやバージョン 1.9 以降では今のところ
   動作しません。
 * Ruby のパッケージ管理システム RubyGems (https://rubygems.org/)
 * Trema 本体。本書は、Trema バージョン 0.3.0 を使用して執筆しています。
 * Trema のコンパイルに必要な gcc や make、およびいくつかのライブラリ。

Trema の実行に必要なのはこれだけです。それでは、Ubuntu のパッケージ管理
システム apt-get を使って必要なパッケージを次のようにインストールしてく
ださい。もし他のディストリビューションを使いたい場合は、コマンド名とパッ
ケージ名を適宜読み替えください。

#+BEGIN_SRC
prompt> sudo apt-get install git gcc make ruby ruby-dev libpcap-dev libsqlite3-dev
#+END_SRC

以上で Trema をインストールするための準備が整いました。続いて Trema を
インストールするには、RubyGems のパッケージで手軽にインストールする方法
と、最新のソースコードを取得して自分でビルドする方法があります。それぞ
れ説明していきましょう。

**** パッケージで手軽にインストールする場合

Trema は RubyGems を使って次のようにコマンド一発で簡単にインストールできます。

#+BEGIN_SRC
prompt> gem install trema
#+END_SRC

RubyGems でインストールした場合、自動的に Trema のコマンド trema にパス
が通っているはずです。次のコマンドでバージョンが表示されればインストー
ルは成功です。

#+BEGIN_SRC
prompt> trema --version
trema version 0.3.0
#+END_SRC

**** ソースコードから最新版をインストールする場合

最新版をインストールしたい人は、GitHub から自分でソースコードをダウンロー
ドしてビルドすることもできます。まず、次のように git を使って最新のソー
スコードを取得してください。

#+BEGIN_SRC
prompt> git clone git://github.com/trema/trema.git
#+END_SRC

次のコマンドを実行すると、Trema が依存する RubyGems のパッケージが自動
的にインストールされます。

#+BEGIN_SRC
prompt> cd trema
prompt> gem install bundler
prompt> bundle install
#+END_SRC

次のコマンドで Trema をダウンロードしたディレクトリ以下に Trema がイン
ストールされます。make install のようなシステム全体へのインストール手順
は不要です。

#+BEGIN_SRC
prompt> ./build.rb
#+END_SRC

次のコマンドで trema コマンドが正しくインストールされたか確認してくださ
い。

#+BEGIN_SRC
prompt> ./trema --version
trema version 0.3.0
#+END_SRC

もし必要あればこのディレクトリにパスを通し、trema コマンドが簡単に起動
できるようにしておいてください。

さあ、これで Trema による OpenFlow 開発環境が整いました。それでは早速、
入門の定番 Hello, World を Trema で書いてみましょう。

*** Hello, Trema!
今から書くアプリケーションは最も簡単な OpenFlow コントローラの一種で、
画面に「 =Hello, Trema!= 」と表示するだけのものです。スイッチとはまった
くやりとりしないスタンドアロンのアプリケーションですが、Trema で作れる
コントローラの基本がすべて入っています。

では、適当なディレクトリにエディタで =hello-trema.rb= というファイルを
開き、次のコードを入力してください。"=.rb=" は Ruby プログラムの標準的
な拡張子です。なお Ruby の文法は必要に応じておいおい説明しますので、も
し分からなくても今のところは気にせずそのまま入力してください。

#+CAPTION: Hello Trema! コントローラ
#+name: src:hello
#+BEGIN_SRC ruby
  class HelloController < Controller
    def start
      puts "Hello, Trema!"
    end
  end
#+END_SRC

意味はまだわからないかもしれませんが、とてもシンプルに見えますね。それ
では細かい文法は後で見るとして「習うより慣れろ」でさっそく実行してみま
しょう。

**** 実行してみよう (trema run)

作成したコントローラは =trema run= コマンドですぐに実行できます。Rubyは
インタプリタ言語なので、コンパイルの必要はありません。ターミナルで次の
ように入力すると、この世界一短い OpenFlow コントローラはフォアグラウン
ドプロセスとして起動し、画面に =Hello, Trema!= と出力します。起動したコ
ントローラは =Ctrl + c= で停止できます。

#+BEGIN_SRC
prompt> cd trema
prompt> ./trema run ./hello-trema.rb
Hello, Trema!  # Ctrl-c で終了
prompt>
#+END_SRC

いかがでしょうか？ trema コマンドを使うと、とても簡単にコントローラを実
行できます。=trema= コマンドは Trema のコマンドラインツールであり、コン
トローラの起動やテストなど様々な用途に使います。たとえば先ほどの
「Hello Trema!」で見たように、 =trema run= はコントローラを起動するため
のコマンドです。起動したコントローラは OpenFlow スイッチと接続しメッセー
ジをやりとりします。

このコントローラは何もしてくれませんが、Trema でコントローラを書くのに
必要な知識がひととおり含まれています。スイッチをつなげるのはちょっと辛
抱して、まずはソースコードを見ていきましょう。

**** コントローラクラスを定義する
Ruby で書く場合、すべてのコントローラは Controller クラスを継承して定義
します ([[src:hello][リスト 1 (1)]])。

Controller クラスを継承することで、コントローラに必要な基本機能が
HelloController クラスにこっそりと追加されます。

**** ハンドラを定義する
Trema はイベントドリブンなプログラミングモデルを採用しています。つまり、
OpenFlow メッセージの到着など各種イベントに対応するハンドラを定義してお
くと、イベントの発生時に対応するハンドラが呼び出されます。たとえば
start メソッドを定義しておくと、コントローラの起動時にこれが自動的に呼
ばれます ([[src:hello][リスト 1 (2)]])。

さて、これで Trema の基本はおしまいです。次は、いよいよ実用的な
OpenFlow コントローラを書いて実際にスイッチをつないでみます。

*** スイッチモニタリングツール
次のお題はスイッチのモニタリングツールです。「今、ネットワーク中にどの
スイッチが動いているか」をリアルタイムに表示しますので、何らかの障害で
落ちてしまったスイッチを発見するのに便利です。

スイッチモニタリングツールは図 2 のように動作します。

OpenFlow スイッチは，起動すると OpenFlow コントローラへ接続しに行きます。
Trema では，スイッチとの接続が確立すると，コントローラの switch_ready
ハンドラが呼ばれます。コントローラはスイッチ一覧リストを更新し，新しく
起動したスイッチをリストに追加します。逆にスイッチが何らかの原因で接続
を切った場合，コントローラの `switch_disconnected` ハンドラが呼ばれます。
コントローラはリストを更新し，いなくなったスイッチをリストから削除しま
す。

**** 仮想ネットワーク

それでは早速，スイッチの起動を検知するコードを書いてみましょう。なんと，
Trema を使えば OpenFlow スイッチを持っていなくてもこうしたコードを実行
してテストできます。いったいどういうことでしょうか?

その答えは，Trema の強力な機能の 1 つ，仮想ネットワーク構築機能にありま
す。これは仮想 OpenFlow スイッチや仮想ホストを接続した仮想ネットワーク
を作る機能です。この仮想ネットワークとコントローラを接続することによっ
て，物理的な OpenFlow スイッチやホストを準備しなくとも，開発マシン 1 台
で OpenFlow コントローラと動作環境を一度に用意して開発できます。もちろ
ん，開発したコントローラは実際の物理的な OpenFlow スイッチやホストで構
成されたネットワークでもそのまま動作します!

それでは仮想スイッチを起動してみましょう。

**** 仮想 OpenFlow スイッチを起動する

仮想スイッチを起動するには，仮想ネットワークの構成を記述した設定ファイ
ルを `trema run` に渡します。たとえば，リスト 2 の設定ファイルでは仮想
スイッチ (`vswitch`) を 2 台定義しています。

#+BEGIN_SRC ruby
vswitch { datapath_id 0xabc }
vswitch { datapath_id 0xdef }
#+END_SRC

リスト2　仮想ネットワークに仮想スイッチを2台追加

それぞれに指定されている `datapath_id` (`0xabc`， `0xdef`) はネットワー
クカードにおける MAC アドレスのような存在で，スイッチを一意に特定する
ID として使われます。OpenFlow の規格によると，64 ビットの一意な整数値を
OpenFlow スイッチ 1 台ごとに割り振ることになっています。仮想スイッチで
は好きな値を設定できるので，かぶらないように適当な値をセットしてくださ
い。

#+BEGIN_SRC ruby
class SwitchMonitor < Controller
  periodic_timer_event :show_switches, 10 # (3)

  def start
    @switches = []
  end

  def switch_ready datapath_id # (1)
    @switches << datapath_id.to_hex
    info "Switch #{ datapath_id.to_hex } is UP"
  end

  def switch_disconnected datapath_id # (2)
    @switches -= [datapath_id.to_hex ]
    info "Switch #{ datapath_id.to_hex } is DOWN"
  end

  private # (3)
  def show_switches
    info "All switches = " + @switches.sort.join( ", " )
  end
end
#+END_SRC

リスト3　SwitchMonitor コントローラ

それでは，さきほど定義したスイッチを起動してコントローラから捕捉してみ
ましょう。スイッチの起動イベントを捕捉するには `switch_ready` ハンドラ
を書きます (リスト 3-1)。

`@switches` は現在起動しているスイッチのリストを管理するインスタンス変
数で，新しくスイッチが起動するとスイッチの `datapath_id` が追加されます。
また，`puts` メソッドで `datapath_id` を表示します。

**** スイッチの切断を捕捉する

同様に，スイッチが落ちて接続が切れたイベントを捕捉してみましょう。この
ためのハンドラは `switch_disconnected` です (リスト 3-2)。

スイッチの切断を捕捉すると，切断したスイッチの `datapath_id` をスイッチ
一覧 `@switches` から除きます。また，`datapath_id` を `puts` メソッドで
表示します。

**** スイッチの一覧を表示する

最後に，スイッチの一覧を定期的に表示する部分を作ります。一定時間ごとに
何らかの処理を行いたい場合には，タイマー機能を使います。リスト 3-3 のよ
うに，一定の間隔で呼びたいメソッドと間隔 (秒数) を
`periodic_timer_event` で指定すると，指定されたメソッドが呼ばれます。こ
こでは，スイッチの一覧を表示するメソッド `show_switches` を 10 秒ごとに
呼び出します。

**** 実行

それでは早速実行してみましょう。仮想スイッチを 3 台起動する場合，リスト
4 の内容のファイルを `switch-monitor.conf` として保存し，設定ファイルを
`trema run` の `-c` オプションに渡してください。

#+BEGIN_SRC ruby
vswitch { datapath_id 0x1 }
vswitch { datapath_id 0x2 }
vswitch { datapath_id 0x3 }
#+END_SRC

リスト4　仮想スイッチを3台定義

実行結果は次のようになります。

#+BEGIN_SRC
    % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
    Switch 0x3 is UP
    Switch 0x2 is UP
    Switch 0x1 is UP
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    ……
#+END_SRC

`switch-monitor` コントローラが起動すると設定ファイルで定義した仮想スイッ
チ 3 台が起動し，`switch-monitor` コントローラの `switch_ready` ハンド
ラによって捕捉され，このメッセージが出力されました。

それでは，スイッチの切断がうまく検出されるか確かめてみましょう。スイッ
チを停止するコマンドは `trema kill` です。別ターミナルを開き，次のコマ
ンドでスイッチ `0x3` を落としてみてください。

#+BEGIN_SRC
    % ./trema kill 0x3
#+END_SRC

すると，`trema run` を動かしたターミナルに次の出力が表示されているはず
です。

#+BEGIN_SRC
    % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
    Switch 0x3 is UP
    Switch 0x2 is UP
    Switch 0x1 is UP
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    All switches = 0x1, 0x2, 0x3
    ……
    Switch 0x3 is DOWN
#+END_SRC

うまくいきました! おわかりのとおり，このメッセージは
`switch_disconnected` ハンドラによって表示されたものです。

**** 友太郎の質問 datapath ってなに?

Q. 「こんにちは! 僕は最近 OpenFlow に興味を持ったプログラマ，友太郎です。
   スイッチに付いている ID を datapath ID って呼ぶのはわかったけど，いっ
   たい datapath ってなに? スイッチのこと?」

A. 実用的には 「datapath = OpenFlow スイッチ」 と考えて問題ありません。

「データパス」 でググると，「CPUは演算処理を行うデータパスと，指示を出
すコントローラから構成されます」 というハードウェア教科書の記述がみつか
ります。つまり，ハードウェアの世界では一般に 「筋肉にあたる部分 = デー
タパス」「脳にあたる部分 = コントローラ」 という分類をするようです。

OpenFlow の世界でも同じ用法が踏襲されています。OpenFlow のデータパスは
パケット処理を行うスイッチを示し，その制御を行うソフトウェア部分をコン
トローラと呼びます。

*** Trema のまとめ
すべてのコントローラのテンプレートとなる Hello, Trema! コントローラを書
きました。また，これを改造してスイッチの動作状況を監視するスイッチモニ
タを作りました。学んだことは次の3つです。

- OpenFlow ネットワークはパケットを処理するスイッチ (datapath) と，スイッ
  チを制御するソフトウェア (コントローラ) から構成される。Trema は，こ
  のコントローラを書くためのプログラミングフレームワークである
- Trema は仮想ネットワーク構築機能を持っており，OpenFlow スイッチを持っ
  ていなくてもコントローラの開発やテストが可能。たとえば，仮想ネットワー
  クに仮想スイッチを追加し，任意の datapath ID を設定できる
- コントローラは Ruby の Controller クラスを継承し，OpenFlow の各種イベ
  ントに対応するハンドラを定義することでスイッチをコントロールできる。
  たとえば，`switch_ready` と `switch_disconnected` ハンドラでスイッチ
  の起動と切断イベントに対応するアクションを書ける

次回はいよいよ本格的なコントローラとして，トラフィック集計機能のあるレ
イヤ 2 スイッチを作ります。初歩的なレイヤ 2 スイッチング機能と，誰がど
のくらいネットワークトラフィックを発生させているかを集計する機能を
OpenFlow で実現します。

**** 友太郎の質問: `switch_ready` ってなに ?

Q. 「OpenFlow の仕様を読んでみたけど，どこにも `switch_ready` って出て
   こなかったよ? OpenFlow にそんなイベントが定義されてるの?」

A. `switch_ready` は Trema 独自のイベントで，スイッチが Trema に接続し
   指示が出せるようになった段階でコントローラに送られます。実は，
   `switch_ready` の裏では図 A の一連の処理が行われており，Trema が
   OpenFlow プロトコルの詳細をうまくカーペットの裏に隠してくれているの
   です。

図A　switch_ready イベントが起こるまで

最初に，スイッチとコントローラがしゃべる OpenFlow プロトコルが合ってい
るか確認します。OpenFlow の `HELLO` メッセージを使ってお互いのプロトコ
ルバージョンを確認し，うまく会話できそうか確認します。

次は，スイッチを識別するための datapath ID の取得です。datapath ID のよ
うなスイッチ固有の情報は，スイッチに対して OpenFlow の Features
Request メッセージを送ることで取得できます。成功した場合，datapath ID
やポート数などの情報が Features Reply メッセージに乗ってやってきます。

最後にスイッチを初期化します。スイッチに以前の状態が残っていると，コン
トローラが管理する情報と競合が起こるため，初期化することでこれを避けま
す。これら一連の処理が終わると，ようやく `switch_ready` がコントローラ
に通知されます。

** OpenFlow 入門
今回は盛りだくさんです！ まずは身近な例を使って，OpenFlow の動作モデル
を説明します。これが理解できれば，OpenFlow の基本概念はバッチリです。次
に，「トラフィック集計付きスイッチ」 を実現するコントローラを実際に作り
ます。これは OpenFlow の重要な処理をすべて含んでいるので，応用するだけ
でさまざまなタイプのコントローラが作れるようになります。最後に，作成し
たコントローラを Trema の仮想ネットワーク上で実行します。すばらしいこと
に，Trema を使えば開発から動作テストまでを開発マシン 1 台だけで完結でき
ます！

では前置きはこのぐらいにして，まずは OpenFlow でスイッチを制御するしく
みを理解しましょう。

*** OpenFlow の動作モデル

OpenFlow の動作を現実世界にたとえると，製品の電話サポートサービスに似て
います。

**** 電話サポートの業務手順

友太郎 (ゆうたろう) 君は，エアコンが故障したので修理に出そうと考えまし
た （図1）。電話サポートに問い合わせると，サポート係の葵 （あおい） さ
んはエアコンの症状を聞き，手元のマニュアルに対処方法が載っている場合に
はこれをすぐに教えてくれます。問題は，マニュアルに対処法が載っていない
場合です。このようなときは少し時間がかかりますが，上司の宮坂主任にどう
したらよいか聞きます。そして，宮坂主任からの回答が得られたら，葵さんは
友太郎君に折り返し電話をします。また，次からの同じ問い合わせにはすばや
く答えられるようにするため，葵さんは教わった対処法を手元のマニュアルに
追加しておきます。

簡単ですね？ 信じられないかもしれませんが，あなたはすでに OpenFlow の
95% を理解したも同然なのです。

![電話サポートの業務手順](https://github.com/trema/Programming-Trema/raw/master/images/2_001.png)

図1　電話サポートの業務手順

**** OpenFlowに置き換えると……

OpenFlow では，お客さんがパケットを発生させるホスト，電話サポート係がス
イッチ，上司がコントローラ，マニュアルがスイッチのフローテーブル (後述)
に対応します （図2）。

![OpenFlowの動作モデル](https://github.com/trema/Programming-Trema/raw/master/images/2_002.png)

図2　OpenFlowの動作モデル

スイッチはホストからのパケットを受信すると，最初はその処理方法がわかり
ません。そこで，上司にあたるコントローラに問い合わせます。この問い合わ
せを `packet_in` メッセージと呼びます。コントローラはこれを受け取ると，
同様のパケットが届いた場合にスイッチでどう処理すべきか (パケットを転送
する，書き換えるなど) を決めます。これをアクションと呼びます。そして
「スイッチで処理すべきパケットの特徴」＋「アクション」 の組 （フローと
呼びます） をスイッチのマニュアルに追加します。この命令を `flow_mod` メッ
セージと呼び，スイッチのマニュアルをフローテーブルと呼びます。処理すべ
きパケットの特徴とアクションをフローテーブルに書いておくことで，以後，
これに当てはまるパケットはスイッチ側だけですばやく処理できます。忘れて
はならないのが，`packet_in` メッセージで上がってきた最初のパケットです。
これはコントローラに上がってきて処理待ちの状態になっているので，
`packet_out` メッセージで適切な宛先に転送してあげます。

電話サポートとの大きな違いは，フローテーブルに書かれたフローには期限が
あり，これを過ぎると消えてしまうということです。これは，「マニュアルに
書かれた内容は徐々に古くなるので，古くなった項目は消す必要がある」 と考
えるとわかりやすいかもしれません。フローが消えるタイミングでコントロー
ラには `flow_removed` メッセージが送信されます。これには，あるフローに
従ってパケットがどれだけ転送されたか -- 電話サポートの例で言うと，マニュ
アルのある項目が何回参照されたか -- つまり，トラフィックの集計情報が記
録されています。

それではしくみの話はこのぐらいにして，早速実践に移りましょう。もし途中
でわからなくなったら，この節の頭から読み直してください。
* すべての基本，ラーニングスイッチを作ろう
** ラーニングスイッチとは何か？
OpenFlow の世界では、コントローラとしてソフトウェア実装したスイッチをよ
くラーニングスイッチと呼びます。なぜ、ラーニング (学習) スイッチと呼ぶ
のでしょうか？それは、スイッチが次のような仕組みで動くからです．

1. 学習: ホストから出たパケットに含まれる、ネットワーク上でのホストの位
   置情報を学習する
2. 転送: 今まで学習してきた位置情報を使って、パケットを宛先のホストまで
   転送する

この「学習し、転送する」というラーニングスイッチの仕組みは応用が広く効
きます。たとえば OpenFlow を使った大規模データセンターネットワークも、
基本はラーニングスイッチと同じく「学習し、転送する」という動作をします。
自宅ネットワークであろうが最新鋭のデータセンターであろうが、その基本的
な考えかたは同じなのです。

このおかげで、ラーニングスイッチを作れるようになれば、それを改造するこ
とでいろいろなアプリケーションを作れるようになります。

- トラフィックモニタ (この章で紹介)
- 複数スイッチ対応ラーニングスイッチ(Tremaのサンプルアプリの1つ)
- ルーティングスイッチ(Trema 本○○章で紹介)

ではさっそく、ネットワークの基本部品であるラーニングスイッチを Trema で
実装してみましょう。まずは一般的なハードウェアスイッチの動作原理を理解
し、次に OpenFlow での実現方法を見ていきます。

*** スイッチの仕組み
簡単なネットワークを例にしてスイッチの動作を説明します
([[fig:switch_network]])。スイッチのポート1番と4番に、ホスト1と2をそれぞれ
接続しています。また、それぞれのホストのネットワークカードは図に示した
MACアドレスを持つとします。

スイッチはホストから届いたパケットを宛先のホストまで転送するために、ス
イッチにつながる各ホストの位置情報をためておくデータベースを持っていま
す。これをフォワーディングデータベース(FDB)と呼び、「ホストのMACアドレ
ス+ポート番号」の組を保持します。

#+CAPTION: スイッチ1台とホスト2台からなるネットワークと、スイッチのFDBの内容
#+NAME: fig:switch_network
[[./images/switch_network.png]]

ここでホスト2がホスト1へパケットを送信すると、スイッチは次のようにパケッ
トをホスト1まで転送します([[fig:host2to1]])。

#+CAPTION: FDB の情報からパケットをホスト 1 に届ける
#+NAME: fig:host2to1
[[./images/host2to1.png]]

1. 届いたパケットの宛先MACアドレス(00:11:11:11:11:11)を見て、このMACア
   ドレスを持つホストがつながるポート番号をFDBから探す
2. FDBには「MACアドレス00:11:11:11:11:11=ポート1」と学習しているので、
   ポート1にパケットを出力する

ここまでの仕組みがわかれば、スイッチの機能を実現するコントローラ(ラーニ
ングスイッチ)をOpenFlowで実現するのは簡単です。

*** OpenFlow版スイッチ(ラーニングスイッチ)の仕組み
OpenFlowによるスイッチの構成は [[fig:switch_network_openflow]] のようになり
ます。一般的なハードウェアスイッチとの違いは次の2つです。

- FDBをソフトウェアとして実装し、コントローラが管理する
- パケットの転送は、コントローラがフローテーブルにフローエントリを書き
  込むことで制御する

なお、初期状態でのFDBとフローテーブルの中身はどちらも空です。

#+CAPTION: OpenFlow によるスイッチ (ラーニングスイッチ) の構成
#+NAME: fig:switch_network_openflow
[[./images/switch_network_openflow.png]]

この状態でホスト1がホスト2へパケットを送信すると、コントローラは次のよ
うにホスト1のネットワーク上での位置情報を学習します
([[fig:host1to2_openflow]])。

1. フローテーブルは空なのでパケットはPacket Inとしてコントローラまで上
   がる
2. コントローラはPacket Inメッセージからパケットの送信元MACアドレスとパ
   ケットの入ってきたポートの番号を調べ、「ポート1番にはMACアドレスが
   00:11:11:11:11:11のホストがつながっている」とFDBに保存する

#+CAPTION: Packet Inの送信元MACアドレスとスイッチのポート番号をFDBに学習する
#+NAME: fig:host1to2_openflow
[[./images/host1to2_openflow.png]]

*** Packet Outでパケットを転送(フラッディング)
学習が終わると次はパケットの転送です。もちろん、パケットの宛先はまだ学
習していないので、コントローラは次のようにパケットをばらまくことで宛先
まで届けます。このばらまく処理をフラッディングと呼びます
([[fig:host1to2_flood_openflow]])。

1. コントローラはPacket Inメッセージの宛先MACアドレスを調べ、FDBから送
   出先のポート番号を探す。しかし、ホスト2のMACアドレスとポート番号はま
   だFDBに入っていないのでわからない
2. コントローラはPacket Outメッセージ(出力ポート=フラッディング)でパケッ
   トをばらまくようにスイッチに指示する。その結果、ポート4につながるホ
   スト2にパケットが届く

#+CAPTION: パケットの宛先MACアドレスからスイッチのポート番号がFDBにみつからないため、Packet Outメッセージ(出力ポート=フラッディング)でパケットをばらまく
#+NAME: fig:host1to2_flood_openflow
[[./images/host1to2_flood_openflow.png]]

*** ふたたび学習と転送(Flow ModとPacket Out)

この状態でホスト2がホスト1へパケットを送信すると次のようになります
([[fig:host2to1_openflow]])。

1. フローテーブルが空なためコントローラまでふたたびPacket Inメッセージが上がる
2. コントローラはこのPacket Inメッセージから「ポート4番にはMACアドレス
   が00:22:22:22:22:22のホストがつながっている」とFDBに保存する
3. Packet Inの宛先MACアドレスとFDBを照らし合わせ、出力先のポート番号を
   探す。ここですでに「ポート1=MACアドレス00:11:11:11:11:11」と学習して
   いるので、出力ポートは1と決定できる
4. 「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエ
   ントリをFlow Modメッセージでフローテーブルに書き込む。加えて、
   Packet Outメッセージ(出力ポート=1)でPacket Inを起こしたパケットをポー
   ト1へ出力する

#+CAPTION: 同様にホスト2のMACアドレスとポート番号をFDBに学習し、フローエントリを書き込むとともにパケットをホスト1に届ける
#+NAME: fig:host2to1_openflow
[[./images/host2to1_openflow.png]]

さて、ここまでの段階でフローテーブルには「ホスト2からホスト1へのパケッ
トはポート1へ出力せよ」というフローエントリが入りました。もし、ホスト2
がホスト1へふたたびパケットを送信すると、今度はPacket Inがコントローラ
まで上がることはなく、スイッチ側だけでパケットを転送します。

残りのホスト1からホスト2へのフローエントリはどうでしょう。すでにFDBはす
べてのホストのMACアドレスとポート番号を学習してあります。もし、ふたたび
ホスト1からホスト2ヘパケットを送信すると、[[fig:host2to1_openflow]] と同様
にコントローラが「ホスト1からホスト2へのパケットはポート4へ出力せよ」と
いうフローエントリを書き込みます。もちろん、それ以降の通信ではPacket
Inはまったく上がらずにすべてスイッチ側だけでパケットを処理します。

ちょっと長くなってしまいましたがOpenFlowによるスイッチの実現方法がわか
りました。いよいよTremaでの実装に移ります。

*** LearningSwitchコントローラ

まずはラーニングスイッチのソースコード ([[list:learning_switch]]) をざっと
眺めてみましょう。とくに =private= の行よりも上のパブリックなメソッドに
注目してください。

#+NAME: list:learning_switch
#+BEGIN_SRC ruby
class LearningSwitch < Controller
  def start
    @fdb = {}
  end

  def packet_in( datapath_id, message )
    @fdb[ message.macsa ] = message.in_port
    port_no = @fdb[ message.macda ]
    if port_no
      flow_mod datapath_id, message, port_no
      packet_out datapath_id, message, port_no
    else
      flood datapath_id, message
    end
  end

  private

  def flow_mod( datapath_id, message, port_no )
    send_flow_mod_add(
      datapath_id,
      :match => ExactMatch.from( message ),
      :actions => SendOutPort.new( port_no )
    )
  end

  def packet_out( datapath_id, message, port_no )
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => SendOutPort.new( port_no )
    )
  end

  def flood( datapath_id, message )
    packet_out datapath_id, message, OFPP_FLOOD
  end
end
#+END_SRC

今までの知識だけでもこれだけたくさんのことがわかります。

- ラーニングスイッチの本体は =LearningSwitch= という名前のクラス
- 起動時に呼ばれる =start= ハンドラでFDBのインスタンス変数を作っている。
  ={}= という文法は見慣れないが、これにMACアドレスとポート番号の組を保
  存するらしい
- 見慣れない =packet_in= メソッドはPacket Inを捕捉するためのハンドラ。
  スイッチのフローエントリにマッチしないパケットがコントローラに上がっ
  てくると、このハンドラが呼ばれる
- Packet In ハンドラの中では、パケットの宛先MACアドレスからFDBでポート
  番号を調べている。もし宛先のポート番号がみつかった場合には、Flow Mod
  でフローエントリを打ち込みPacket Outでパケットを送信している。もしポー
  ト番号がみつからなかった場合は =flood= というメソッドを呼んでいる。こ
  れは先述した「パケットをばらまく(フラッディング)」の処理

いかがでしょうか。ラーニングスイッチの心臓部は Packet In ハンドラだけで、
その中身もやっていることはなんとなくわかると思います。細かい実装の解説
は後回しにして、さっそく実行してみましょう。

*** 実行してみよう

今回も仮想ネットワークを使って、仮想スイッチ1台、仮想ホスト2台の構成で
ラーニングスイッチを起動してみます。次の内容の設定ファイルを
=learning-switch.conf= として保存してください。

#+BEGIN_SRC ruby
vswitch("lsw") {
  datapath_id "0xabc"
}

vhost ("host1") {
  ip "192.168.0.1"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:01"
}

vhost ("host2") {
  ip "192.168.0.2"
  netmask "255.255.0.0"
  mac "00:00:00:01:00:02"
}

link "lsw", "host1"
link "lsw", "host2"
#+END_SRC

=vhost= は仮想ホストの設定です。この設定ファイルでは =host1=, =host2=
という名前の2つの仮想ホストを起動します。また, =link= は仮想リンクで、
指定した仮想スイッチと仮想ホストを接続できます。ここでは、仮想スイッチ
=lsw= と、仮想ホスト =host1=, =host2= をそれぞれ仮想リンクで接続してい
ます。

次のように =trema run= の =-c= オプションにこの設定ファイルを渡してラー
ニングスイッチを実行します。ラーニングスイッチ自体の出力はありません。

#+BEGIN_SRC
prompt> trema run ./learning-switch.rb -c ./learning-switch.conf
#+END_SRC

別ターミナルを開き, =trema send_packets= コマンドを使ってhost1とhost2の
間でテストパケットを送ってみます。

#+BEGIN_SRC
prompt> trema send_packets --source host1 --dest host2
prompt> trema send_packets --source host2 --dest host1
#+END_SRC

=trema show_stats= コマンドでhost1 と host2の受信パケット数をチェックし、
それぞれでパケットを受信していれば成功です。

#+BEGIN_SRC
prompt> trema show_stats host1 --rx
ip_dst,tp_dst,ip_src,tp_src,n_pkts,n_octets
192.168.0.1,1,192.168.0.2,1,1,50
prompt> trema show_stats host2 --rx
ip_dst,tp_dst,ip_src,tp_src,n_pkts,n_octets
192.168.0.2,1,192.168.0.1,1,1,50
#+END_SRC

*** LearningSwitchのソースコード

それではラーニングスイッチのソースコードを読み解いていきましょう。今回
の肝となるのは、Packet Inハンドラでの次の処理です。

- FDBの更新とポート番号の検索
- ポート番号がみつかった場合の、Flow ModとPacket Out処理
- ポート番号がみつからなかった場合のフラッディング処理

それでは、最初にPacket Inハンドラの定義方法から見ていきましょう。

**** 未知のパケット(Packet In)の処理

コントローラに上がってくる未知のパケットを拾うには、Packet Inハンドラを
コントローラクラスに実装します。典型的なPacket Inハンドラは次のようにな
ります ([[list:learning_switch]]より抜粋)。

#+BEGIN_SRC ruby
class LearningSwitch < Controller
  # ...

  def packet_in( datapath_id, message )
    # ...
  end

  # ...
#+END_SRC

最初の引数 =datapath_id= は、Packet Inを上げたスイッチのDatapath IDです。
二番目の引数 =message= は =PacketIn= クラスのインスタンスで、Packet In
メッセージをオブジェクトとしてラップしたものです。この =PacketIn= クラ
スには主に次の3種類のメソッドが定義されています。

- Packet Inを起こしたパケットのデータやその長さ、およびパケットが入って
  きたスイッチのポート番号などOpenFlowメッセージ固有の情報を返すメソッ
  ド
- Packet Inを起こしたパケットの種別(TCPかUDPか？またVLAN タグの有無な
  ど)を判定するための =?= で終わるメソッド
- 送信元や宛先のMACアドレス、IPアドレスなど、パケットの各フィールドを調
  べるためのアクセサメソッド

=PacketIn= クラスは非常に多くのメソッドを持っており、またTremaのバージョ
ンアップごとにその数も増え続けているためすべては紹介しきれません。付録
に代表的でよく使うものを紹介します。

**** FDBの更新とポート番号の検索
知らないパケットがPacket Inとして入ってきたとき、ラーニングスイッチは次
のようにFDBにホストの位置情報を学習し、宛先のポート番号を調べます。

1. パケットの送信元MACアドレスとパケットが入ってきたポート番号をPacket
   Inメッセージから取り出し、FDB(=@fdb=)に保存する
2. パケットの宛先MACアドレスとFDBから、パケットを出力するポート番号を調べる

FDBの実装は単純にハッシュテーブルを使っているだけなので、ひっかかる箇所
は無いと思います。

#+BEGIN_SRC ruby
class LearningSwitch < Controller
  # ...

  def packet_in( datapath_id, message )
    @fdb[ message.macsa ] = message.in_port
    port_no = @fdb[ message.macda ]

    # ...
  end

  # ...
end
#+END_SRC

**** 宛先ポート番号がみつかった場合(Flow ModとPacket Out)
もし宛先ポートがみつかった場合、以降は同じパケットは同様に転送せよ、と
いうフローエントリをスイッチに書き込みます(=flow_mod= メソッド)。また、
Packet Inを起こしたパケットも忘れずにそのポートへ出力します
(=packet_out= メソッド)。

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...
  port_no = @fdb[ message.macda ]
  if port_no
    flow_mod datapath_id, message, port_no
    packet_out datapath_id, message, port_no
  else

  # ...
#+END_SRC

この =flow_mod= メソッドと =packet_out= メソッドはそれぞれ=Controller=
クラスの =send_flow_mod_add= および =send_packet_out= (Packet Outの送
信)メソッドを次のように呼び出します。

#+BEGIN_SRC ruby
  # ...

  private

  def flow_mod( datapath_id, message, port_no )
    send_flow_mod_add(
      datapath_id,
      :match => ExactMatch.from( message ),
      :actions => SendOutPort.new( port_no )
    )
  end

  def packet_out( datapath_id, message, port_no )
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => SendOutPort.new( port_no )
    )
  end
  # ...
#+END_SRC

ここでいくつか見慣れない要素が登場しています。

- =send_flow_mod_add= の中では、マッチングルールに=ExactMatch.from= の
  返り値を指定している
- Packet Outの送信用メソッド (=send_packet_out=)

それでは、それぞれの詳細を見て行きましょう。

**** Exact Matchの作り方
マッチングルールの中でもすべての条件を指定したものをExact Matchと呼びま
す。たとえばPacket Inとしてコントローラに入ってきたパケットと、

- パケットが入ってきたスイッチのポート番号
- 送信元 MAC アドレス
- 宛先 MAC アドレス
- ...

などなどマッチングルールが定義する12個の条件がすべてまったく同じ、とい
うのがExact Matchです。

もし、Exact Matchを普通に作るとどうなるでしょうか？

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_flow_mod_add(
    datapath_id,
    :match => Match.new(
      :in_port => message.in_port
      :dl_src => message.macsa,
      :dl_dst => message.macda,
      # ...
#+END_SRC

うーん。やりたいことは分かりますが、マッチングルールを1つ作るだけでこの
ようにいちいち10行以上も書いていたらしんどいですよね。

そこで、TremaではこのようなExact Matchを楽に書ける次のショートカットを
用意しています。

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_flow_mod_add(
    datapath_id,
    :match => ExactMatch.from( message ),
    # ...
#+END_SRC

なんとたった1行で書けました! Tremaではこのようにプログラムを短く書ける
工夫がたくさんあります。これはそのつど紹介していくことにしましょう。

ところで今回のラーニングスイッチの例では、スイッチに書き込まれるフロー
エントリは次の2パターンだけです。

1. ホスト1からホスト2
2. ホスト2からホスト1

今回は流れるパケットの種類も限られていますので、フローエントリのマッチ
ングルールを楽に作るためにExact Macthを使っています。

**** Packet Out API
Packet OutはOpenFlowで定義されたメッセージの1つで、スイッチの指定したポー
トからパケットを送信させるためのものです。TremaでPacket Outを送るための
メソッド, =send_packet_out= は次の2つの引数を取ります。

#+BEGIN_SRC ruby
send_packet_out(datapath_id, options)
#+END_SRC

それぞれの引数の意味は次のとおりです。

- =datapath_id=: Packet Outの届け先となるスイッチのDatapath ID
- =options=: Packet Outメッセージの中身を決めるためのオプションで、アク
  ションによるパケットの書き換えや出力するポートを指定する。これはハッ
  シュテーブルで定義されていて、必要なオプションのみを指定すればいいこ
  とになっている

Packet Outの使い道は、Packet Inメッセージとして入ってきたパケットをその
ままスイッチのポートから送り出す場合がほとんどです。この場合、パケット
の送信にスイッチのバッファを使う場合と使わない場合とで呼び出しかたが変
わります。

***** スイッチのバッファを使ってPacket Outする場合
パケットのデータがスイッチのバッファに乗っていることが期待できる場合に
は、次のように =:buffer_id= オプションでバッファに乗っているパケットデー
タのIDを指定してやることでPacket Outできます。

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_packet_out(
    datapath_id,
    :buffer_id => message.buffer_id,
    :data => message.data,
    :actions => SendOutPort.new( port_number )
  )
#+END_SRC

この場合コントローラからスイッチへのパケットデータのコピーが起こらない
ため、若干のスピードアップが期待できます。ただし、バッファの中身は予測
不能でいつデータが消えるかわからないため、この方法は推奨しません。

***** スイッチのバッファを使わずに Packet Out する場合
スイッチのバッファを使わずにPacket Outする場合、次のように =:data=オプ
ションでパケットのデータを指定する必要があります。バッファに乗っている
かいないかにかかわらずPacket Outできるので、若干遅くなりますが安全です。

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_packet_out(
    datapath_id,
    :data => message.data,
    :actions => SendOutPort.new( port_number )
  )
#+END_SRC

これは、次のように =:packet_in= オプションを使うことで若干短くできます
(=.data= を書かなくてよくなります)。

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...

  send_packet_out(
    datapath_id,
    :packet_in => message,
    :actions => SendOutPort.new( port_number )
  )
#+END_SRC

=options= に指定できる主なオプションは付録を参照してください。

**** 宛先ポート番号がみつからなかった場合(フラッディング)
もし宛先ポートがみつからなかった場合、コントローラはPacket Inしたメッセー
ジをフラッディングしてばらまきます。これをやっているのが =flood= メソッ
ドで、実体は =packet_out= メソッドのポート番号に仮想ポート番号
=OFPP_FLOOD= を指定しているだけです。これが指定されたPacket Outメッセー
ジをスイッチが受け取ると、指定されたパケットをフラッディングします。

#+BEGIN_SRC ruby
def packet_in( datapath_id, message )
  # ...
  port_no = @fdb[ message.macda ]
  if port_no
    # ...
  else
    flood datapath_id, message
  end
  # ...
end

private

# ...

def flood( datapath_id, message )
  packet_out datapath_id, message, OFPP_FLOOD
end
#+END_SRC

*** まとめ
さまざまなOpenFlowアプリケーションのベースとなるラーニングスイッチの動
作と作り方を学びました。

- コントローラは、Packet Inメッセージから送信元ホストのMACアドレスとホ
  ストのつながるスイッチポート番号をFDBに学習する
- Packet Inの転送先がFDBから分かる場合、Flow Modで以降の転送情報をスイッ
  チに書き込みPacket Outする。FDBで決定できない場合は、入力ポート以外の
  すべてのポートにPacket Outでフラッディングする。

続いてはこのラーニングスイッチを少し改造してトラフィック集計機能を加え
ます。

** 「トラフィック集計スイッチ」 コントローラの概要
トラフィック集計スイッチは，パっと見は普通の L2 スイッチとして動作しま
す。しかし，裏では各ホストが送信したトラフィックをカウントしており，定
期的に集計情報を表示してくれます。これを使えば，ネットワークを無駄に使
いすぎているホストを簡単に特定できます。

*** 設計と実装
「L2 スイッチ機能」と「トラフィックの集計機能」のためにはどんな部品が必
要でしょうか？ まずは，スイッチに指示を出す上司にあたるコントローラクラ
スが必要です。これを `TrafficMonitor` クラスと名付けましょう。また，パ
ケットを宛先のスイッチポートへ届けるための `FDB` クラス (注1)，あとはト
ラフィックを集計するための `Counter` クラスの 3 つが最低限必要です。

注1) FDB とは Forwarding DataBase の略で，スイッチの一般的な機能です。
詳しくは続く実装で説明します。

**** FDBクラス
`FDB` クラス (リスト1) は，ホストの MAC アドレスとホストが接続している
スイッチポートの対応を学習するデータベースです。このデータベースを参照
することで，`packet_in` メッセージで入ってきたパケットの宛先 MAC アドレ
スからパケット送信先のスイッチポートを決定できます。

#+BEGIN_SRC ruby
class FDB
  def initialize
    @db = {} # <- 連想配列(MACアドレス→スイッチポート番号)
  end

  def lookup mac # <- MACアドレスからスイッチポート番号を引く
    @db[ mac ]
  end

  def learn mac, port_number # <- MACアドレス＋スイッチポートを学習
    @db[ mac ] = port_number
  end
end
#+END_SRC

リスト1　MACアドレス→スイッチポートのデータベースFDBクラス(fdb.rb)

**** Counter クラス
`Counter` クラス (リスト2) は，ホスト （MAC アドレスで区別します） ごと
の送信パケット数およびバイト数をカウントします。また，カウントした集計
情報を表示するためのヘルパメソッドを提供します。

#+BEGIN_SRC ruby
class Counter
  def initialize
    @db = {} # <- ホストごとの集計情報を記録する連想配列
  end

  def add mac, packet_count, byte_count # <- ホスト (MAC アドレス = mac) の送信パケット数、バイト数を追加
    @db[ mac ] ||= { :packet_count => 0, :byte_count => 0 }
    @db[ mac ][ :packet_count ] += packet_count
    @db[ mac ][ :byte_count ] += byte_count
  end

  def each_pair &block # <- 集計情報の表示用
    @db.each_pair &block
  end
end
#+END_SRC

リスト2　トラフィックを記録し集計する `Counter` クラス (`counter.rb`)

**** TrafficMonitor クラス
`TrafficMonitor` クラスはコントローラの本体です (リスト3)。メインの処理
はリスト 3 1-3 の 3 つになります。

1. `packet_in` メッセージが到着したとき，パケットを宛先のスイッチポートに転送し，フローテーブルを更新する部分
2. `flow_removed` メッセージが到着したとき，トラフィック集計情報を更新する部分
3. タイマーで 10 秒ごとにトラフィックの集計情報を表示する部分

#+BEGIN_SRC ruby
require "counter"
require "fdb"

class TrafficMonitor < Controller
  periodic_timer_event :show_counter, 10 # (3)

  def start
    @counter = Counter.new # <- Counter オブジェクト
    @fdb = FDB.new # <- FDB オブジェクト
  end

  def packet_in datapath_id, message # (1)
    macsa = message.macsa # <- パケットを送信したホストの MAC アドレス
    macda = message.macda # <- パケットの宛先ホストの MAC アドレス

    @fdb.learn macsa, message.in_port
    @counter.add macsa, 1, message.total_len
    out_port = @fdb.lookup( macda )
    if out_port
      packet_out datapath_id, message, out_port
      flow_mod datapath_id, macsa, macda, out_port
    else
      flood datapath_id, message
    end
  end

  def flow_removed datapath_id, message # (2)
    @counter.add message.match.dl_src,message.packet_count, message.byte_count
  end

  private # <- 以下、プライベートメソッド

  def show_counter # <- カウンタを表示
    puts Time.now
    @counter.each_pair do | mac, counter |
      puts "#{ mac } #{ counter[ :packet_count ] } packets (#{ counter[ :byte_count ] } bytes)"
    end
  end

  def flow_mod datapath_id, macsa, macda, out_port # <- macsa から macda へのパケットを out_port へ転送する flow_mod を打つ
    send_flow_mod_add(
      datapath_id,
      :hard_timeout => 10, # <- flow_mod の有効期限は10秒
      :match => Match.new( :dl_src => macsa, :dl_dst => macda ),
      :actions => Trema::ActionOutput.new( out_port )
    )
  end

  def packet_out datapath_id, message, out_port # <- packet_in したメッセージを out_port へ転送
    send_packet_out(
      datapath_id,
      :packet_in => message,
      :actions => Trema::ActionOutput.new( out_port )
    )
  end

  def flood datapath_id, message # <- packet_inしたメッセージをin_port以外の全スイッチポートへ転送
    packet_out datapath_id, message, OFPP_FLOOD
  end
end
#+END_SRC

リスト3　本体 `TrafficMonitor` クラス (`traffic-monitor.rb`)

それでは，とくに重要な (1) の処理を詳しく見ていきましょう。なお，リスト
3 中で使われているメソッドの引数など API の詳細については，「Trema
Ruby API ドキュメント」 を参照してください。

以下の説明では図 3 に示すホスト 2 台 + スイッチ 1 台からなるネットワー
ク構成を使います。host1 から host2 にパケットを送信したときの動作シーケ
ンスは図 4 のようになります。

#+CAPTION: TrafficMonitor を動作させるネットワーク構成の例
[[https://github.com/trema/Programming-Trema/raw/master/images/2_003.png]]
図3　`TrafficMonitor` を動作させるネットワーク構成の例

#+CAPTION: host1からhost2宛にパケットを送信したときの動作シーケンス
[[https://github.com/trema/Programming-Trema/raw/master/images/2_004.png]]
図4　`host1` から `host2` 宛にパケットを送信したときの動作シーケンス

1. `host1` から `host2` を宛先としてパケットを送信すると，まずはスイッ
   チにパケットが届く
2. スイッチのフローテーブルは最初はまっさらで，どう処理すればよいかわか
   らない状態なので，コントローラである `TrafficMonitor` に
   `packet_in` メッセージを送る
3. `TrafficMonitor` の `packet_in` メッセージハンドラでは，`packet_in`
   メッセージの `in_port` (`host1` のつながるスイッチポート) と
   `host1` の MAC アドレスを FDB に記録する
4. また，`Counter` に記録された `host1` の送信トラフィックを 1 パケット
   分増やす
5. `packet_in` メッセージの宛先 MAC アドレスから転送先のスイッチポート
   番号を FDB に問い合わせる。この時点では `host2` のスイッチポートは学
   習していないので，結果は 「不明」
6. そこで，パケットを `in_port` 以外のすべてのスイッチポートに出力する
   `packet_out` メッセージ (FLOOD と呼ばれる) をスイッチに送り，
   `host2` が受信してくれることを期待する
7. スイッチは，パケットを `in_port` 以外のすべてのポートに出す

これで，最終的に `host2` がパケットを受信できます。逆に，この状態で
`host1` を宛先として `host2` からパケットを送信したときの動作シーケンス
は次のとおりになります (図5)。4 までの動作は図 4 と同じですが，5 からの
動作が次のように異なります。

#+CAPTION: host1 から host2 宛にパケットを送信したときの動作シーケンス
[[https://github.com/trema/Programming-Trema/raw/master/images/2_005.png]]
図5　host1 から host2 宛にパケットを送信したときの動作シーケンス

1. `host1` から `host2` を宛先としてパケットを送信すると，まずはスイッ
   チにパケットが届く
2. スイッチのフローテーブルは最初はまっさらで，どう処理すればよいかわか
   らない状態なので，コントローラである `TrafficMonitor` に
   `packet_in` メッセージを送る
3. `TrafficMonitor` の `packet_in` メッセージハンドラでは，`packet_in`
   メッセージの `in_port` (`host1` のつながるスイッチポート) と
   `host1` の MAC アドレスを FDB に記録する
4. また，`Counter` に記録された `host1` の送信トラフィックを 1 パケット
   分増やす
5. `packet_in` メッセージの宛先 MAC アドレスから，転送先のスイッチポー
   ト番号を FDB に問い合わせる。これは，先ほど `host1` から `host2` に
   パケットを送った時点で FDB に学習させているので，送信先はスイッチポー
   ト 1 番ということがわかる
6. そこで，`TrafficMonitor` はパケットをスイッチポート 1 番へ出力する
   `packet_out` メッセージをスイッチに送る。スイッチはこれを受け取ると，
   パケットをスイッチポート 1 番に出し，最終的に `host1` がパケットを受
   信する
7. 「送信元 = 00:00:00:00:00:02，送信先 = 00:00:00:00:00:01 となるパケッ
   トはスイッチポート 1 番に転送せよ」 という `flow_mod` メッセージをス
   イッチに送信する

最後の 7 によって，以降の `host2` から `host1` へのパケットはすべてスイッ
チ側だけで処理されるようになります。

** 実行してみよう

それでは，早速実行してみましょう (注2)。リスト 4 の内容の仮想ネットワー
ク設定を `traffic-monitor.conf` として保存し，次のように実行してくださ
い。

#+BEGIN_SRC
prompt> ./trema run ./traffic-monitor.rb -c ./traffic-monitor.conf
#+END_SRC
リスト 4　仮想スイッチ `0xabc` に仮想ホスト `host1`，`host2` を接続する設定

#+BEGIN_SRC ruby
vswitch { # <- 仮想スイッチ 0xabc を定義
  datapath_id 0xabc
}

vhost ("host1") { # <- 仮想ホスト host1 を定義
  ip "192.168.0.1"
  mac "00:00:00:00:00:01"
}

vhost ("host2") { # <- 仮想ホスト host2 を定義
  ip "192.168.0.2"
  mac "00:00:00:00:00:02"
}

link "0xabc", "host1" # <- ホスト host1、host2 をスイッチ 0xabc に接続
link "0xabc", "host2"
#+END_SRC

実行すると，図 3 に示した仮想ネットワークが構成され，`TrafficMonitor`
コントローラが起動します。

それでは，実際にトラフィックを発生させて集計されるか見てみましょう。
Trema の `send_packets` コマンドを使うと，仮想ホスト間で簡単にパケット
を送受信できます。別ターミナルを開き，次のコマンドを入力してください。

#+BEGIN_SRC
prompt> ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10← host1からhost2宛にパケットを10個送る
prompt> ./trema send_packets --source host2 --dest host1 --n_pkts 10 --pps 10← host2からhost1宛にパケットを10個送る
#+END_SRC

`trema run` を実行した元のターミナルに次のような出力が出ていれば成功です(注3)。

#+BEGIN_SRC
    ...
    00:00:00:00:00:01 10 packets (640 bytes)
    ↑host1からパケットが10個送信された

    00:00:00:00:00:02 10 packets (640 bytes)
    ↑host2からパケットが10個送信された
    ...
#+END_SRC

注2) Trema のセットアップが済んでいない人は，前回もしくは Trema のドキュ
メントを参考にセットアップしておいてください。なお，Trema は頻繁に更新
されていますので，すでにインストールしている人も最新版にアップデートす
ることをお勧めします。

注3) その他のトラフィック情報も出るかもしれませんが，これは Linux カー
ネルが送っている IPv6 のパケットなので，`host1`， `host2` とは関係あり
ません。

** まとめ
今回は 「トラフィック集計機能付きスイッチ」 を実現するコントローラを書
きました。学んだことは次の2つです。

- 電話サポートの例を使って OpenFlow の動作モデルを学びました。パケット
  の転送はスイッチ上のフローテーブルによって行われ，`flow_mod` メッセー
  ジによって書き換えることができます。また，フローテーブルに登録されて
  いないパケットによって `packet_in` メッセージがコントローラに届きます。
- 仮想ネットワークを使ったコントローラの動作テスト方法を学びました。仮
  想スイッチと仮想ホストを起動してつなぎ，`send_packets` コマンドを使っ
  て仮想ホスト間でパケットを送受信することで，コントローラの簡単な動作
  テストができます。

次回は Trema を使ったテストファースト開発を紹介します。Rails や
Sinatra を使った Web アジャイル開発ではお馴染みのテストファースト開発で
すが，もちろん Trema でもサポートしています。とくに OpenFlow コントロー
ラのように複雑な動作シーケンスを持つソフトウェアの実装には，テストファー
ストによるインクリメンタルな開発が有効です。

* 実践! 生活ネットワークを OpenFlow に移行しよう
そろそろ独り立ちするときがやってきました．これまで本連載では，OpenFlow
コントローラの書き方と Trema の仮想ネットワークを使った実行方法を学び
ました．OpenFlow プログラマとしてやっていくための基本的な知識はすべて
身に付きました．

次はなにをすればよいでしょうか？あとはやってみるだけです．まずは自宅の
ネットワークを OpenFlow で置き換えましょう．うまくいったら，こんどは職
場のネットワークを OpenFlow で置き換えましょう．その環境で実際に暮らし
てみて，初めて見えてくるアイデアや改善案があります．これは，とにかくやっ
てみなければ絶対にわからないことです．

「怒られるかもしれない」．あなたはそう考えます．家のネットワークはとも
かく，職場のネットワークを止めてしまったらどうしよう…．管理者や上司に
注意されたらどうしよう…．大丈夫です．筆者たちも何度も怒られたことがあ
りますが，その経験からうまくやる方法を学びました．

今回は我々の経験を踏まえ，既存のネットワークを "穏便" に OpenFlow へ移
行するためのテクニックを教えます．ちょっとした OpenFlow プログラムを書
くだけで，移行の際に起こりがちなネットワーク障害を簡単に防げます．まず
は，筆者たちの失敗談を振り返らせてください．

** 失敗談
話は 2009 年 7 月までさかのぼります．OpenFlow が登場したばかりの当時，
筆者たちはさっそく OpenFlow コントローラを書いて小さなネットワークを職
場に構築しました．うまく動作して気を良くした我々は，職場のネットワーク
とこの OpenFlow ネットワークをいきなりつないでみました．まあ大丈夫だろ
うと楽観的に考えていたのです．結果的にはすぐにネットワーク障害が起こり，
事態に気づいた管理者からお叱りのメールを受け取ることになりました．

当時の状況を単純化すると図 1 のようになります．

#+CAPTION: 障害を起こしたときのネットワーク構成を簡略化したもの
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/001.png]]

職場ネットワーク (レガシーネットワークとします) のスイッチにはホストが
つながれており，そのうちのスイッチポート 3 番を OpenFlow スイッチポート
の 1 番と接続しました．この OpenFlow スイッチは，我々が書いた
BuggyController という OpenFlowコントローラで制御されています．

*** 「警告が出ているんですけど」
具体的な障害の症状はこうでした．レガシーネットワークと OpenFlow ネット
ワークを接続してすぐに，レガシースイッチにつながったホストどうしが通信
できなくなりました．そして，ネットワークを監視する watchdog プログラム
が「Host Flapping が起こっている」という警告を出しました．これは，1 つ
のホストがいくつかのポートの間で高速に移動しているように見えるというも
のです．我々はすぐに OpenFlow ネットワークを切断し，原因の分析にとりか
かりました．

*** 障害の原因
分析の結果，次のようなシナリオで起こっているのではないかという結論に至
りました．

1. host1 が host2 へパケットを送信する
2. BuggyController は OpenFlow スイッチポート 1 番からの packet_in を
   受け取り，OpenFlow スイッチのスイッチポート 1 番に host1 がつながっ
   ていると学習する
3. host2 が host1 へパケットを送信する
4. BuggyController はスイットポート 1 番から「宛先=host1」の packet_in
   を受け取る．ここで，host1 は OpenFlow スイッチのスイッチポート 1 番
   にあると学習しているので，スイッチポート 1 番に packet_out する
5. 結果的に，host1 はポート 2 と 3 の両方から同じパケットを受け取る．
   外から見ると，host2 がスイッチポート 2 番と 3 番を高速に移動してい
   るように見える．

つまり，BuggyController が予期せぬパケットをレガシーネットワークに送っ
たおかげでネットワークが混乱し，通信できない状況が起きたのです．

*** 教訓: これをやってはいけない
振り返ると，失敗した原因は 2 つありました．

1 つは，OpenFlow ネットワークをいきなりレガシーネットワークとつないで
しまったことです．OpenFlow ネットワーク単体では動いていたという言い訳
はありますが，いきなりつないでしまったのは若気の至り & 経験不足でした．

もう 1 つは，BuggyController が packet_in したスイッチポートに
packet_out していたことです．assert を入れるなど防御的プログラミングが
徹底できていれば防げるバグでしたが，残念ながら当時の我々では気づくこと
ができませんでした．レガシーネットワークにつないで初めて顕在化するバグ
と言えます．

** OpenFlow への移行パターン
大失敗をやらかしてしまった筆者たちは，作戦を練りなおさざるを得なくなり
ました。いろいろな方向から考えなおしたところ，OpenFlow への移行方法には
次の 3 つのパターンがあることがわかりました。もちろん，それぞれでメリッ
ト／デメリットや危険度が異なります。

*** 独立ネットワークパターン
最初のパターンは，既存のレガシーネットワークにまったく手を加えずに，独
立した形でOpenFlowネットワークを構築する方法です（図2）。それぞれのネッ
トワーク間でパケットの行き来はなく，お互いに完全に独立しています。

#+CAPTION: レガシーネットワークとは独立した OpenFlow ネットワークを構築し，徐々に拡大する
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/002.png]]

この状態から，レガシーネットワーク内のサーバや端末を徐々にOpenFlowネッ
トワークに移動することで移行していきます。

それぞれのネットワーク間ではパケットが行き来できないので，OpenFlowネッ
トワークがレガシーネットワークに悪影響を及ぼす可能性はほとんどありませ
ん。ただし，OpenFlowネットワークに移行する際には関連する機器どうし（ファ
イルサーバとクライアント群など）を一度に移行する必要があります。これは
トラブルを起こす可能性が高いため，移行が難しいという問題があります。

*** いきなり接続パターン
次のパターンは，我々がやったようにレガシーネットワークとOpenFlowネット
ワークをいきなりつなげてしまう方法です（図3）。

#+CAPTION: レガシーネットワークと OpenFlow ネットワークを直結してしまう
http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/003.png

相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできま
す。このため，独立ネットワークパターンに比べて移行の手間はずっと小さい
と言えます。

OpenFlowネットワークのコントローラが完璧に作られていれば，このようにい
きなりつなげても問題はありませんが，完璧なテストというのは難しいです。
ユニットテストによって関数レベルで細かくテストすることもできますが（注
4），それだけでは不十分です。というのも，我々が失敗したように，生のトラ
フィックをコントローラに流し込んでみて初めて見つかるバグがあるからです。
よって，この方法は自宅ネットワークなど自由にいじれるネットワーク以外で
は推奨できません。

*** 逆流防止パターン
最後のパターンは，今までに挙げてきた2つのパターンのいいとこどりです。2
つのネットワークを接続するのですが，そのときに「逆流防止弁」を付けてパ
ケットの逆流が起きないようにします（図4）。

#+CAPTION: レガシーネットワークとOpenFlowネットワークの間での逆流を防止する
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/004.png]]

たとえば，「レガシーネットワーク→OpenFlowネットワーク」のような一方向
のパケットは通しますが，同じパケットがレガシー側に戻ることを防ぎます。
逆方向でも同じです。

この方法の利点は，逆流を防ぐだけでかなりの障害を未然に防げることです。
また，使い勝手はいきなり接続した場合と同じなのでOpenFlowへの移行も楽で
す。

検討の結果，このパターンが一番良さそうでした。この逆流防止弁はOpenFlow
コントローラとして実装できそうです。前置きが長くなりましたが，さっそく
Tremaを使って実装してみましょう。

** 逆流防止弁
逆流防止弁は1つのpacket_inに対して2つのフローを設定します。1つは順方向
のフローで，入ってきたパケットをもう1つのスイッチポートに転送します。も
う1つは逆方向のフローで，同じパケットが逆方向に流れてきたときにこのパケッ
トを落とします。

*** 実装
逆流防止弁（OneWayBridgeコントローラ）のソースコードをリスト1に示します。
このコントローラは，packet_inとflow_removedのハンドラを定義しています。

#+BEGIN_SRC ruby
  class OneWayBridge < Controller
    # 順方向と逆方向のフローを設定する
    def packet_in datapath_id, message
      out_port = { 1 => 2, 2 => 1 }[ message.in_port ]
      add_flow datapath_id, message.macsa, message.in_port, out_port
      send_packet datapath_id, message, out_port
      add_drop_flow datapath_id, message.macsa, out_port
    end

    # 順方向と逆方向のフローのいずれかが消えたときに，もう1つも消す
    def flow_removed datapath_id, message
      delete_flow datapath_id, message.match.dl_src
    end

    # 以下，プライベートメソッド
    private

    # 送信元MACアドレスがmacsaで，スイッチポートin_portからout_portへのフローを追加
    def add_flow datapath_id, macsa, in_port, out_port
      send_flow_mod_add(
        datapath_id,
        :idle_timeout => 10 * 60,
        :match => Match.new( :in_port => in_port, :dl_src => macsa ),
        :actions => ActionOutput.new( :port => out_port )
      )
    end

    # パケットをスイッチポートout_portへ転送
    def send_packet datapath_id, message, out_port
      send_packet_out(
        datapath_id,
        :packet_in => message,
        :actions => ActionOutput.new( :port => out_port )
      )
    end

    # 逆流してきたパケットを落とすフローを追加（:actionsを指定していないので，マッチしたパケットを落とす）
    def add_drop_flow datapath_id, macsa, in_port
      send_flow_mod_add(
        datapath_id,
        :idle_timeout => 10 * 60,
        :match => Match.new( :in_port => in_port, :dl_src => macsa )
      )
    end

    # 順方向と逆方向のフローを両方とも消す
    def delete_flow datapath_id, macsa
      send_flow_mod_delete(
        datapath_id,
        :match => Match.new( :dl_src => macsa )
      )
    end
  end
#+END_SRC

Packet In ハンドラ (=packet_in= メソッド) では，Packet In したスイッチ
ポートとは別のポートへパケットを転送するフロー (たとえば，スイッチポー
ト 1 番から入ってきたパケットはスイッチポート 2 番に転送するフロー) を
設定し (=add_flow= メソッド)，実際にパケットを転送します
(=send_packet= メソッド)。また，同じパケットが逆向きに流れないようにす
るフローを設定することで逆流を防ぎます (=add_drop_flow= メソッド)。

Flow Removed ハンドラ (=flow_removed= メソッド) は，順方向または逆方向
のフローが消えたときに呼ばれます。これらのフローはどちらも =:dl_src= に
同じ MAC アドレスが指定されているので =delete_flow= メソッドでもう片方
を消します。なおここではやっていませんが，Flow Removed メッセージに乗っ
てくる統計情報[fn:1]を使って，逆流パケットがあった場合には警告メッセー
ジを出すようにするとさらに効果的でしょう。

[fn:1] 「トラフィック集計スイッチ」でこのテクニックを使いました。

*** 実行
それではさっそく実行してみましょう。実行のためには，レガシーネットワー
クとOpenFlowネットワークの間にOneWayBridgeコントローラで制御する仮想ス
イッチ（vswitch）をはさみます（図5）。vswitchのポートは，vswitchを実行
するマシンのNIC（eth0，eth1）に結び付けます。

#+CAPTION: 逆流防止弁（OneWayBridgeコントローラ）を実行するときの物理構成
[[http://image.gihyo.co.jp/assets/images/dev/serial/01/openflow_sd/0011/005.png]]

図5の物理構成をTrema設定ファイルにしたものがリスト
2（one-way-bridge.conf）です。仮想リンク（link で始まる行）の端点にイン
ターフェース名eth0，eth1を指定していることに注目してください。

#+CAPTION: 逆流防止弁（OneWayBridgeコントローラ）の設定ファイル
#+BEGIN_SRC ruby
vswitch ( "bridge" ) {
  datapath_id 0xabc
}

link "bridge", "eth0"
link "bridge", "eth1"
#+END_SRC

実行するには，この設定ファイルをtrema runの-cオプションに渡します。

#+BEGIN_SRC
prompt> ./trema run ./one-way-bridge.rb -c ./one-way-bridge.conf
#+END_SRC

*** 使ってみた
さっそくこの逆流防止弁を導入したところ，期待していたとおり，問題は起こ
らなくなりました。現在，OpenFlowスイッチ5台，ホスト約100台から構成され
るOpenFlowネットワークを職場ネットワークと接続して運用しています。もち
ろん，このOpenFlowネットワークはどんどん拡大しつつあり，ゆくゆくは職場
ネットワークを置き換える予定です。

** まとめ

職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました。今
回学んだことは次の2つです。

- 既存のレガシーネットワークをOpenFlowに移行するいくつかのパターンを見
  ました。自宅ネットワークなど自由にできるネットワークでは「いきなり接
  続パターン」で十分ですが，職場ネットワークでは「逆流防止パターン」が
  最適です
- 逆流防止弁を実現するOpenFlowコントローラを実装しました。基本的には2つ
  のフローを設定するだけで，簡単に逆流を防止できます

* 付録
** PacketIn クラスの主なメソッド
: @<tt>{:data}
  パケットのデータ全体をバイナリ文字列で返す

: @<tt>{:in_port}
  パケットが入ってきたスイッチのポート番号を返す

: @<tt>{:total_len}
  パケットのデータ長を返す

: @<tt>{:buffered?}
  Packet Inを起こしたパケットがスイッチにバッファされているかどうかを返す

: @<tt>{:macsa}
  パケットの送信元MACアドレスを返す

: @<tt>{:macda}
  パケットの宛先MACアドレスを返す

: @<tt>{:ipv4?}
  パケットがIPv4である場合@<tt>{true}を返す

: @<tt>{:ipv4_saddr}
  パケットの送信元IPアドレスを返す

: @<tt>{:ipv4_daddr}
  パケットの宛先IPアドレスを返す

: @<tt>{:tcp?}
  パケットがTCPである場合@<tt>{true}を返す

: @<tt>{:tcp_src_port}
  パケットのTCPの送信元ポート番号を返す

: @<tt>{:tcp_dst_port}
  パケットのTCP宛先ポート番号を返す

: @<tt>{:udp?}
  パケットがUDPである場合@<tt>{true}を返す

: @<tt>{:udp_src_port}
  パケットのUDPの送信元ポート番号を返す

: @<tt>{:udp_dst_port}
  パケットのUDPの宛先ポート番号を返す

: @<tt>{:vtag?}
  パケットにVLANヘッダが付いている場合@<tt>{true}を返す

: @<tt>{:vlan_vid}
  VLANのVIDを返す

このようなメソッドは他にもたくさんあります。メソッドの完全なリストや詳
しい情報を知りたい場合には、@<chap>{openflow_framework_trema}で紹介した
@<tt>{trema ruby}コマンドで最新のTrema APIドキュメントを参照してくださ
い。
** send_packet_out の主なオプション
: @<tt>{:buffer_id}
  スイッチでバッファされているパケットのIDを指定する。この値を使うと、
  スイッチでバッファされているパケットを指定してPacket Outできるので効
  率が良くなる(ただし、スイッチにバッファされていない時はエラーになる)

: @<tt>{:data}
  Packet Outするパケットの中身を指定する。もし@<tt>{:buffer_id}オプショ
  ンが指定されておりスイッチにバッファされたパケットをPacket Outする場
  合、この値は使われない

: @<tt>{:packet_in}
  @<tt>{:data}および@<tt>{:in_port} オプションを指定するためのショート
  カット@<fn>{in_port_option}。@<tt>{packet_in}ハンドラの引数として渡さ
  れる@<tt>{PacketIn}メッセージを指定する

: @<tt>{:actions}
  Packet Outのときに実行したいアクションの配列を指定する。アクションが
  1つの場合は配列でなくてかまわない

footnote[in_port_option][@<tt>{:in_port}オプションは出力ポートに@<tt>{OFPP_TABLE}という特殊なポートを指定したときに使うオプションです。通常はまったく使いませんが、もし知りたい方はTrema Ruby APIを参照してください。]
